     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_list"
     .align 8
mrc_list:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_even$q"
     .align 8
mrc_even$q:
     .int 0xFF
     .global "mrc_odd$q"
     .align 8
mrc_odd$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_current$minput$mport"
     .align 8
mrc_current$minput$mport:
     .int 0xFF
     .global "mrc_port$mkind"
     .align 8
mrc_port$mkind:
     .int 0xFF
     .global "mrc_port$mpath"
     .align 8
mrc_port$mpath:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$minput$mport"
     .align 8
mrc_close$minput$mport:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_base$mwrite"
     .align 8
mrc_base$mwrite:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_display"
     .align 8
mrc_display:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .global "mrc_standard$min"
     .align 8
mrc_standard$min:
     .int 0xFF
     .global "mrc_port$munread"
     .align 8
mrc_port$munread:
     .int 0xFF
     .global "mrc_port$munread$mclear"
     .align 8
mrc_port$munread$mclear:
     .int 0xFF
     .global "mrc_port$munread$mset$b"
     .align 8
mrc_port$munread$mset$b:
     .int 0xFF
     .global "mrc_port$mlast"
     .align 8
mrc_port$mlast:
     .int 0xFF
     .global "mrc_port$mlast$mset$b"
     .align 8
mrc_port$mlast$mset$b:
     .int 0xFF
     .global "mrc_input$mport$q"
     .align 8
mrc_input$mport$q:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$minput$mfile"
     .align 8
mrc_open$minput$mfile:
     .int 0xFF
     .global "mrc_read$mchar"
     .align 8
mrc_read$mchar:
     .int 0xFF
     .global "mrc_fill$minput$mbuffer"
     .align 8
mrc_fill$minput$mbuffer:
     .int 0xFF
     .global "mrc_unread$mchar"
     .align 8
mrc_unread$mchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (lambda () f310787))
# == vectorize-letrec  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (lambda () f310787))
# == eliminate-set!  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f310787)))
# == close-free-variables  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (closure () (f310787) (let () f310787)))
# == eliminate-quote  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (closure () (f310787) (let () f310787)))
# == eliminate-when/unless  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (closure () (f310787) (let () f310787)))
# == eliminate-cond  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (closure () (f310787) (let () f310787)))
# == external-symbols  ==>
# (let ((f310787 (cons (make-symbol "nil" ()) ()))) (closure () (f310787) (let () f310787)))
# emit-expr (let ((f310787 (cons (make-symbol "nil" ()) ()))) (closure () (f310787) (let () f310787)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310787 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f310787) (let () f310787))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_1883600
    .align 8,0x90
_L_1883599 :
    .int 12
    .ascii "nil"
_L_1883600:
    movl $_L_1883599, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f310787) (let () f310787))
# emit-closure
# si = -4
# env = ((f310787 . 0))
# expr = (closure () (f310787) (let () f310787))
    movl $_L_1883601, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310787 . 0))
# var=f310787
    movl 0(%esp), %eax  # stack load f310787
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310787
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883602            # jump around closure body
_L_1883601:
# check argument count
    cmp $0,%eax
    je _L_1883603
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883603:
# emit-tail-expr
# si=-8
# env=((f310787 . 4) (f310787 . 0))
# expr=(let () f310787)
# emit-tail-let
#  si   = -8
#  env  = ((f310787 . 4) (f310787 . 0))
#  bindings = ()
#  body = f310787
# emit-tail-expr
# si=-8
# env=((f310787 . 4) (f310787 . 0))
# expr=f310787
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310787 . 4) (f310787 . 0))
# var=f310787
    movl 2(%edi), %eax  # frame load f310787
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1883602:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f310791 (lambda (f310813 f310812) (fx= (string-length f310813) (string-length f310812)))) (f310790 (lambda (f310811 f310810 f310809) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))) (f310789 (lambda (f310808 f310807 f310806 f310805) (if (fx= f310806 f310805) #t (if (f310790 f310808 f310807 f310806) (f310789 f310808 f310807 (fx+ f310806 1) f310805) #f)))) (f310788 (lambda (f310804 f310803) (if (f310791 f310804 f310803) (f310789 f310804 f310803 0 (string-length f310804)) #f)))) f310788)
# == vectorize-letrec  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (lambda (f310813 f310812) (fx= (string-length f310813) (string-length f310812)))) (vector-set! f310790 0 (lambda (f310811 f310810 f310809) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))) (vector-set! f310789 0 (lambda (f310808 f310807 f310806 f310805) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)))) (vector-set! f310788 0 (lambda (f310804 f310803) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))) (vector-ref f310788 0)))
# == eliminate-set!  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (lambda (f310813 f310812) (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (lambda (f310811 f310810 f310809) (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (lambda (f310808 f310807 f310806 f310805) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (lambda (f310804 f310803) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == close-free-variables  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == eliminate-quote  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == eliminate-when/unless  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == eliminate-cond  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == external-symbols  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# emit-expr (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1)))
#  body = (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883604"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883604:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883605
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883605:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883606"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883606:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883607
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883607:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883608"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883608:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883609
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883609:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883610"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883610:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883611
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883611:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0))
# emit-begin
#   expr=(begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812)))))
# emit-expr f310791
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310791
    movl 0(%esp), %eax  # stack load f310791
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883612
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883612:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883613"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883613:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883615
    cmp  $0,%eax
    jge _L_1883614
_L_1883615:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883614:
    movl %eax, -20(%esp)
# emit-expr (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))
    movl $_L_1883616, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883617            # jump around closure body
_L_1883616:
# check argument count
    cmp $8,%eax
    je _L_1883618
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883618:
# emit-tail-expr
# si=-16
# env=((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812)))
# emit-tail-let
#  si   = -16
#  env  = ((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310813 f310813) (f310812 f310812))
#  body = (fx= (string-length f310813) (string-length f310812))
# emit-expr f310813
# emit-variable-ref
# env=((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310813
    movl -8(%esp), %eax  # stack load f310813
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310812
# emit-variable-ref
# env=((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310812
    movl -12(%esp), %eax  # stack load f310812
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310812 . -20) (f310813 . -16) (f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(fx= (string-length f310813) (string-length f310812))
# tail primcall
# emit-expr (string-length f310812)
# emit-expr f310812
# emit-variable-ref
# env=((f310812 . -20) (f310813 . -16) (f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310812
    movl -20(%esp), %eax  # stack load f310812
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883619
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883619:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883620"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883620:
    movl %eax, -24(%esp)
# emit-expr (string-length f310813)
# emit-expr f310813
# emit-variable-ref
# env=((f310812 . -20) (f310813 . -16) (f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310813
    movl -16(%esp), %eax  # stack load f310813
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883621
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883621:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883622"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883622:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f310813) (string-length f310812))
    ret
    .align 4,0x90
_L_1883617:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))))
# emit-expr f310790
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310790
    movl -4(%esp), %eax  # stack load f310790
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883623
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883623:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883624"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883624:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883626
    cmp  $0,%eax
    jge _L_1883625
_L_1883626:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883625:
    movl %eax, -20(%esp)
# emit-expr (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))
    movl $_L_1883627, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883628            # jump around closure body
_L_1883627:
# check argument count
    cmp $12,%eax
    je _L_1883629
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883629:
# emit-tail-expr
# si=-20
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))
# emit-tail-let
#  si   = -20
#  env  = ((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310811 f310811) (f310810 f310810) (f310809 f310809))
#  body = (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))
# emit-expr f310811
# emit-variable-ref
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310811
    movl -8(%esp), %eax  # stack load f310811
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f310810
# emit-variable-ref
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310810
    movl -12(%esp), %eax  # stack load f310810
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310809
# emit-variable-ref
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310809
    movl -16(%esp), %eax  # stack load f310809
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(char=? (string-ref f310811 f310809) (string-ref f310810 f310809))
# tail primcall
# char= c1=(string-ref f310811 f310809) c2=(string-ref f310810 f310809)
# emit-expr (string-ref f310811 f310809)
# emit-expr f310811
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310811
    movl -20(%esp), %eax  # stack load f310811
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883630
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883630:
    movl %eax, -32(%esp)
# emit-expr f310809
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310809
    movl -28(%esp), %eax  # stack load f310809
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883631"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883631:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1883633
    cmp  $0,%eax
    jge _L_1883632
_L_1883633:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883632:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1883634"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883634:
    movb %ah, -32(%esp)
# emit-expr (string-ref f310810 f310809)
# emit-expr f310810
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310810
    movl -24(%esp), %eax  # stack load f310810
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883635
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883635:
    movl %eax, -36(%esp)
# emit-expr f310809
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310809
    movl -28(%esp), %eax  # stack load f310809
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883636"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883636:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1883638
    cmp  $0,%eax
    jge _L_1883637
_L_1883638:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883637:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1883639"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883639:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))
    ret
    .align 4,0x90
_L_1883628:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)))))
# emit-expr f310789
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310789
    movl -8(%esp), %eax  # stack load f310789
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883640
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883640:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883641"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883641:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883643
    cmp  $0,%eax
    jge _L_1883642
_L_1883643:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883642:
    movl %eax, -20(%esp)
# emit-expr (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))
    movl $_L_1883644, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310790
    movl -4(%esp), %eax  # stack load f310790
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310790
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310789
    movl -8(%esp), %eax  # stack load f310789
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f310789
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1883645            # jump around closure body
_L_1883644:
# check argument count
    cmp $16,%eax
    je _L_1883646
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883646:
# emit-tail-expr
# si=-24
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805))
#  body = (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))
# emit-expr f310808
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310808
    movl -8(%esp), %eax  # stack load f310808
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310807
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310807
    movl -12(%esp), %eax  # stack load f310807
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -16(%esp), %eax  # stack load f310806
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f310805
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310805
    movl -20(%esp), %eax  # stack load f310805
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))
# emit-expr (fx= f310806 f310805)
# emit-expr f310805
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310805
    movl -36(%esp), %eax  # stack load f310805
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883649"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883649:
    movl %eax, -40(%esp)
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -32(%esp), %eax  # stack load f310806
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883650"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883650:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883647
# emit-tail-expr
# si=-40
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1883648
_L_1883647:
# emit-tail-expr
# si=-40
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)
# emit-expr ((vector-ref f310790 0) f310808 f310807 f310806)
# funcall
#    si   =-40
#    env  = ((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310790 0) f310808 f310807 f310806)
# emit-expr (vector-ref f310790 0)
# emit-expr f310790
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310790
    movl 2(%edi), %eax  # frame load f310790
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883653
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883653:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883654"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883654:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883656
    cmp  $0,%eax
    jge _L_1883655
_L_1883656:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883655:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883657"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883657":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f310808
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310808
    movl -24(%esp), %eax  # stack load f310808
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f310808
# emit-expr f310807
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310807
    movl -28(%esp), %eax  # stack load f310807
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f310807
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -32(%esp), %eax  # stack load f310806
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f310806
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1883651
# emit-tail-expr
# si=-40
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805)
# emit-tail-funcall
#    si   =-40
#    env  = ((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805)
# emit-expr (vector-ref f310789 0)
# emit-expr f310789
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310789
    movl 6(%edi), %eax  # frame load f310789
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883658
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883658:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883659"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883659:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883661
    cmp  $0,%eax
    jge _L_1883660
_L_1883661:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883660:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310808
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310808
    movl -24(%esp), %eax  # stack load f310808
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f310808
# emit-expr f310807
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310807
    movl -28(%esp), %eax  # stack load f310807
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f310807
# emit-expr (fx+ f310806 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883662"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883662:
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -32(%esp), %eax  # stack load f310806
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883663"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883663:
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg (fx+ f310806 1)
# emit-expr f310805
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310805
    movl -36(%esp), %eax  # stack load f310805
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f310805
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1883652
_L_1883651:
# emit-tail-expr
# si=-40
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1883652:
_L_1883648:
    .align 4,0x90
_L_1883645:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))
# emit-expr f310788
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310788
    movl -12(%esp), %eax  # stack load f310788
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883664
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883664:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883665"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883665:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883667
    cmp  $0,%eax
    jge _L_1883666
_L_1883667:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883666:
    movl %eax, -20(%esp)
# emit-expr (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))
    movl $_L_1883668, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310791
    movl 0(%esp), %eax  # stack load f310791
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310791
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310789
    movl -8(%esp), %eax  # stack load f310789
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f310789
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1883669            # jump around closure body
_L_1883668:
# check argument count
    cmp $8,%eax
    je _L_1883670
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883670:
# emit-tail-expr
# si=-16
# env=((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310804 f310804) (f310803 f310803))
#  body = (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -8(%esp), %eax  # stack load f310804
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310803
# emit-variable-ref
# env=((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310803
    movl -12(%esp), %eax  # stack load f310803
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)
# emit-expr ((vector-ref f310791 0) f310804 f310803)
# funcall
#    si   =-24
#    env  = ((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310791 0) f310804 f310803)
# emit-expr (vector-ref f310791 0)
# emit-expr f310791
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310791
    movl 2(%edi), %eax  # frame load f310791
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883673
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883673:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883674"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883674:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883676
    cmp  $0,%eax
    jge _L_1883675
_L_1883676:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883675:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883677"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883677":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -16(%esp), %eax  # stack load f310804
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310804
# emit-expr f310803
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310803
    movl -20(%esp), %eax  # stack load f310803
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310803
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1883671
# emit-tail-expr
# si=-24
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=((vector-ref f310789 0) f310804 f310803 0 (string-length f310804))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310789 0) f310804 f310803 0 (string-length f310804))
# emit-expr (vector-ref f310789 0)
# emit-expr f310789
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310789
    movl 6(%edi), %eax  # frame load f310789
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883678
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883678:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883679"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883679:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883681
    cmp  $0,%eax
    jge _L_1883680
_L_1883681:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883680:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -16(%esp), %eax  # stack load f310804
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310804
# emit-expr f310803
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310803
    movl -20(%esp), %eax  # stack load f310803
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310803
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f310804)
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -16(%esp), %eax  # stack load f310804
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883682
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883682:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg (string-length f310804)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1883672
_L_1883671:
# emit-tail-expr
# si=-24
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1883672:
    .align 4,0x90
_L_1883669:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (begin (vector-ref f310788 0))
# emit-begin
#   expr=(begin (vector-ref f310788 0))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-ref f310788 0)
# emit-expr f310788
# emit-variable-ref
# env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310788
    movl -12(%esp), %eax  # stack load f310788
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883683
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883683:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883684"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883684:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883686
    cmp  $0,%eax
    jge _L_1883685
_L_1883686:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883685:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
# (letrec ((f310814 (lambda (f310824 f310823) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) (f310814 f310824 (cdr f310823))))))) (lambda (f310832) (f310814 f310832 (symbols))))
# == vectorize-letrec  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (lambda (f310824 f310823) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))) (lambda (f310832) ((vector-ref f310814 0) f310832 (symbols)))))
# == eliminate-set!  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (lambda (f310824 f310823) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (lambda (f310832) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == close-free-variables  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == eliminate-quote  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == eliminate-cond  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == external-symbols  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols)))))))
# emit-expr (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310814 (make-vector 1)))
#  body = (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883687"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883687:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883688
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883688:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
#   env=((f310814 . 0))
# emit-expr (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))))
# emit-begin
#   expr=(begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))))
#   env=((f310814 . 0))
# emit-expr (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))
# emit-expr f310814
# emit-variable-ref
# env=((f310814 . 0))
# var=f310814
    movl 0(%esp), %eax  # stack load f310814
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883689
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883689:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883690"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883690:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883692
    cmp  $0,%eax
    jge _L_1883691
_L_1883692:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883691:
    movl %eax, -8(%esp)
# emit-expr (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))
# emit-closure
# si = -12
# env = ((f310814 . 0))
# expr = (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))
    movl $_L_1883693, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310814 . 0))
# var=f310814
    movl 0(%esp), %eax  # stack load f310814
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310814
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883694            # jump around closure body
_L_1883693:
# check argument count
    cmp $8,%eax
    je _L_1883695
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883695:
# emit-tail-expr
# si=-16
# env=((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))
# emit-tail-let
#  si   = -16
#  env  = ((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#  bindings = ((f310824 f310824) (f310823 f310823))
#  body = (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -8(%esp), %eax  # stack load f310824
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -12(%esp), %eax  # stack load f310823
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))
# emit-expr ((primitive-ref string=?) f310824 (symbol->string (car f310823)))
# funcall
#    si   =-24
#    env  = ((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#    expr = (funcall (primitive-ref string=?) f310824 (symbol->string (car f310823)))
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883698"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883698":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -16(%esp), %eax  # stack load f310824
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310824
# emit-expr (symbol->string (car f310823))
# symbol->string (car f310823)
# emit-expr (car f310823)
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883699
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883699:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
    mov %eax, -40(%esp)  # arg (symbol->string (car f310823))
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1883696
# emit-tail-expr
# si=-24
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(car f310823)
# tail primcall
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883700
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883700:
    movl -1(%eax), %eax
#return from tail (car f310823)
    ret
    jmp _L_1883697
_L_1883696:
# emit-tail-expr
# si=-24
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))
# emit-expr (null? (cdr f310823))
# emit-expr (cdr f310823)
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883703
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883703:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883701
# emit-tail-expr
# si=-24
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828)))
# emit-tail-let
#  si   = -24
#  env  = ((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#  bindings = ((f310828 (make-symbol f310824 #f)))
#  body = (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))
# emit-expr (make-symbol f310824 #f)
# make-symbol arg1=f310824 arg2=#f
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -16(%esp), %eax  # stack load f310824
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))
# emit-tail-let
#  si   = -28
#  env  = ((f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#  bindings = ((f310830 (cons f310828 ())))
#  body = (begin (set-cdr! f310823 f310830) f310828)
# emit-expr (cons f310828 ())
# cons arg1=f310828 arg2=()
# emit-expr f310828
# emit-variable-ref
# env=((f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310828
    movl -24(%esp), %eax  # stack load f310828
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(begin (set-cdr! f310823 f310830) f310828)
# tail-begin (begin (set-cdr! f310823 f310830) f310828)
#   env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# emit-expr (set-cdr! f310823 f310830)
# emit-expr f310823
# emit-variable-ref
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883704
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883704:
    movl %eax, -32(%esp)
# emit-expr f310830
# emit-variable-ref
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310830
    movl -28(%esp), %eax  # stack load f310830
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(begin f310828)
# tail-begin (begin f310828)
#   env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# emit-tail-expr
# si=-32
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=f310828
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310828
    movl -24(%esp), %eax  # stack load f310828
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_1883702
_L_1883701:
# emit-tail-expr
# si=-24
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=((vector-ref f310814 0) f310824 (cdr f310823))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#    expr = (funcall (vector-ref f310814 0) f310824 (cdr f310823))
# emit-expr (vector-ref f310814 0)
# emit-expr f310814
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310814
    movl 2(%edi), %eax  # frame load f310814
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883705
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883705:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883706"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883706:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883708
    cmp  $0,%eax
    jge _L_1883707
_L_1883708:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883707:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -16(%esp), %eax  # stack load f310824
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310824
# emit-expr (cdr f310823)
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883709
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883709:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f310823)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1883702:
_L_1883697:
    .align 4,0x90
_L_1883694:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310814 . 0))
# emit-expr (begin (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
#   env=((f310814 . 0))
# emit-expr (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f310814 . 0))
# expr = (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols)))))
    movl $_L_1883710, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310814 . 0))
# var=f310814
    movl 0(%esp), %eax  # stack load f310814
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310814
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883711            # jump around closure body
_L_1883710:
# check argument count
    cmp $4,%eax
    je _L_1883712
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883712:
# emit-tail-expr
# si=-12
# env=((f310832 . -8) (f310814 . 4) (f310814 . 0))
# expr=(let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f310832 . -8) (f310814 . 4) (f310814 . 0))
#  bindings = ((f310832 f310832))
#  body = ((vector-ref f310814 0) f310832 ((primitive-ref symbols)))
# emit-expr f310832
# emit-variable-ref
# env=((f310832 . -8) (f310814 . 4) (f310814 . 0))
# var=f310832
    movl -8(%esp), %eax  # stack load f310832
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310832 . -12) (f310832 . -8) (f310814 . 4) (f310814 . 0))
# expr=((vector-ref f310814 0) f310832 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f310832 . -12) (f310832 . -8) (f310814 . 4) (f310814 . 0))
#    expr = (funcall (vector-ref f310814 0) f310832 ((primitive-ref symbols)))
# emit-expr (vector-ref f310814 0)
# emit-expr f310814
# emit-variable-ref
# env=((f310832 . -12) (f310832 . -8) (f310814 . 4) (f310814 . 0))
# var=f310814
    movl 2(%edi), %eax  # frame load f310814
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883713
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883713:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883714"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883714:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883716
    cmp  $0,%eax
    jge _L_1883715
_L_1883716:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883715:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310832
# emit-variable-ref
# env=((f310832 . -12) (f310832 . -8) (f310814 . 4) (f310814 . 0))
# var=f310832
    movl -12(%esp), %eax  # stack load f310832
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310832
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f310832 . -12) (f310832 . -8) (f310814 . 4) (f310814 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883717"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883717":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1883711:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310814 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
# (lambda (f310834 f310833) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833))))
# == vectorize-letrec  ==>
# (lambda (f310834 f310833) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833))))
# == eliminate-set!  ==>
# (lambda (f310834 f310833) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == close-free-variables  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == eliminate-quote  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == eliminate-when/unless  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == eliminate-cond  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == external-symbols  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))))
# emit-expr (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))))
    movl $_L_1883718, 0(%ebp)  # closure label
# WARNING: free var nil not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883719            # jump around closure body
_L_1883718:
# check argument count
    cmp $8,%eax
    je _L_1883720
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883720:
# emit-tail-expr
# si=-16
# env=((f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833))))
# emit-tail-let
#  si   = -16
#  env  = ((f310833 . -12) (f310834 . -8) (nil . 4))
#  bindings = ((f310834 f310834) (f310833 f310833))
#  body = (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -8(%esp), %eax  # stack load f310834
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310833
# emit-variable-ref
# env=((f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310833
    movl -12(%esp), %eax  # stack load f310833
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))
# emit-expr (null? f310834)
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -16(%esp), %eax  # stack load f310834
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883721
# emit-tail-expr
# si=-24
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(cons f310833 nil)
# tail primcall
# cons arg1=f310833 arg2=nil
# emit-expr f310833
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310833
    movl -20(%esp), %eax  # stack load f310833
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f310833 nil)
    ret
    jmp _L_1883722
_L_1883721:
# emit-tail-expr
# si=-24
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833))
# tail primcall
# cons arg1=(car f310834) arg2=((primitive-ref append1) (cdr f310834) f310833)
# emit-expr (car f310834)
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -16(%esp), %eax  # stack load f310834
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883723
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883723:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref append1) (cdr f310834) f310833)
# funcall
#    si   =-28
#    env  = ((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f310834) f310833)
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883724"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883724":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f310834)
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -16(%esp), %eax  # stack load f310834
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883725
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883725:
    movl 3(%eax), %eax
    mov %eax, -40(%esp)  # arg (cdr f310834)
# emit-expr f310833
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310833
    movl -20(%esp), %eax  # stack load f310833
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f310833
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833))
    ret
_L_1883722:
    .align 4,0x90
_L_1883719:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
# (lambda (f310836 f310835) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1))))
# == vectorize-letrec  ==>
# (lambda (f310836 f310835) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1))))
# == eliminate-set!  ==>
# (lambda (f310836 f310835) (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == close-free-variables  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == eliminate-quote  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == eliminate-when/unless  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == eliminate-cond  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == external-symbols  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))))
# emit-expr (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))))
    movl $_L_1883726, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883727            # jump around closure body
_L_1883726:
# check argument count
    cmp $8,%eax
    je _L_1883728
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883728:
# emit-tail-expr
# si=-16
# env=((f310835 . -12) (f310836 . -8))
# expr=(let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f310835 . -12) (f310836 . -8))
#  bindings = ((f310836 f310836) (f310835 f310835))
#  body = (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))
# emit-expr f310836
# emit-variable-ref
# env=((f310835 . -12) (f310836 . -8))
# var=f310836
    movl -8(%esp), %eax  # stack load f310836
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310835
# emit-variable-ref
# env=((f310835 . -12) (f310836 . -8))
# var=f310835
    movl -12(%esp), %eax  # stack load f310835
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# expr=(if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))
# emit-expr (fx= f310835 0)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883731"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883731:
    movl %eax, -24(%esp)
# emit-expr f310835
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310835
    movl -20(%esp), %eax  # stack load f310835
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883732"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883732:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883729
# emit-tail-expr
# si=-24
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# expr=(car f310836)
# tail primcall
# emit-expr f310836
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310836
    movl -16(%esp), %eax  # stack load f310836
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883733
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883733:
    movl -1(%eax), %eax
#return from tail (car f310836)
    ret
    jmp _L_1883730
_L_1883729:
# emit-tail-expr
# si=-24
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# expr=((primitive-ref list-ref) (cdr f310836) (fx- f310835 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
#    expr = (funcall (primitive-ref list-ref) (cdr f310836) (fx- f310835 1))
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f310836)
# emit-expr f310836
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310836
    movl -16(%esp), %eax  # stack load f310836
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883734
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883734:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f310836)
# emit-expr (fx- f310835 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883735"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883735:
    movl %eax, -32(%esp)
# emit-expr f310835
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310835
    movl -20(%esp), %eax  # stack load f310835
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883736"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883736:
    subl -32(%esp), %eax
    mov %eax, -32(%esp)    # arg (fx- f310835 1)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1883730:
    .align 4,0x90
_L_1883727:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f310837) (if (null? f310837) 0 (fxadd1 (list-length (cdr f310837)))))
# == vectorize-letrec  ==>
# (lambda (f310837) (if (null? f310837) 0 (fxadd1 (list-length (cdr f310837)))))
# == eliminate-set!  ==>
# (lambda (f310837) (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 (list-length (cdr f310837))))))
# == close-free-variables  ==>
# (closure (f310837) () (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 (list-length (cdr f310837))))))
# == eliminate-quote  ==>
# (closure (f310837) () (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 (list-length (cdr f310837))))))
# == eliminate-when/unless  ==>
# (closure (f310837) () (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 (list-length (cdr f310837))))))
# == eliminate-cond  ==>
# (closure (f310837) () (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 (list-length (cdr f310837))))))
# == external-symbols  ==>
# (closure (f310837) () (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 ((primitive-ref list-length) (cdr f310837))))))
# emit-expr (closure (f310837) () (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 ((primitive-ref list-length) (cdr f310837))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310837) () (let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 ((primitive-ref list-length) (cdr f310837))))))
    movl $_L_1883737, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883738            # jump around closure body
_L_1883737:
# check argument count
    cmp $4,%eax
    je _L_1883739
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883739:
# emit-tail-expr
# si=-12
# env=((f310837 . -8))
# expr=(let ((f310837 f310837)) (if (null? f310837) 0 (fxadd1 ((primitive-ref list-length) (cdr f310837)))))
# emit-tail-let
#  si   = -12
#  env  = ((f310837 . -8))
#  bindings = ((f310837 f310837))
#  body = (if (null? f310837) 0 (fxadd1 ((primitive-ref list-length) (cdr f310837))))
# emit-expr f310837
# emit-variable-ref
# env=((f310837 . -8))
# var=f310837
    movl -8(%esp), %eax  # stack load f310837
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310837 . -12) (f310837 . -8))
# expr=(if (null? f310837) 0 (fxadd1 ((primitive-ref list-length) (cdr f310837))))
# emit-expr (null? f310837)
# emit-expr f310837
# emit-variable-ref
# env=((f310837 . -12) (f310837 . -8))
# var=f310837
    movl -12(%esp), %eax  # stack load f310837
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883740
# emit-tail-expr
# si=-16
# env=((f310837 . -12) (f310837 . -8))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_1883741
_L_1883740:
# emit-tail-expr
# si=-16
# env=((f310837 . -12) (f310837 . -8))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f310837)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f310837))
# funcall
#    si   =-16
#    env  = ((f310837 . -12) (f310837 . -8))
#    expr = (funcall (primitive-ref list-length) (cdr f310837))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883742"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883742":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f310837)
# emit-expr f310837
# emit-variable-ref
# env=((f310837 . -12) (f310837 . -8))
# var=f310837
    movl -12(%esp), %eax  # stack load f310837
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883743
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883743:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f310837)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883744"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883744:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f310837)))
    ret
_L_1883741:
    .align 4,0x90
_L_1883738:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f310838 (lambda (f310842 f310841) (if (null? f310842) f310841 (f310838 (cdr f310842) (cons (car f310842) f310841)))))) (lambda (f310844) (f310838 f310844 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (lambda (f310842 f310841) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))) (lambda (f310844) ((vector-ref f310838 0) f310844 (quote ())))))
# == eliminate-set!  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (lambda (f310842 f310841) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (lambda (f310844) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 (quote ()))))))
# == close-free-variables  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# == eliminate-when/unless  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# == eliminate-cond  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# == external-symbols  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# emit-expr (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310838 (make-vector 1)))
#  body = (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883745"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883745:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883746
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883746:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
#   env=((f310838 . 0))
# emit-expr (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))))
# emit-begin
#   expr=(begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))))
#   env=((f310838 . 0))
# emit-expr (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))
# emit-expr f310838
# emit-variable-ref
# env=((f310838 . 0))
# var=f310838
    movl 0(%esp), %eax  # stack load f310838
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883747
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883747:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883748"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883748:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883750
    cmp  $0,%eax
    jge _L_1883749
_L_1883750:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883749:
    movl %eax, -8(%esp)
# emit-expr (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))
# emit-closure
# si = -12
# env = ((f310838 . 0))
# expr = (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))
    movl $_L_1883751, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310838 . 0))
# var=f310838
    movl 0(%esp), %eax  # stack load f310838
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310838
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883752            # jump around closure body
_L_1883751:
# check argument count
    cmp $8,%eax
    je _L_1883753
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883753:
# emit-tail-expr
# si=-16
# env=((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=(let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))
# emit-tail-let
#  si   = -16
#  env  = ((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
#  bindings = ((f310842 f310842) (f310841 f310841))
#  body = (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -8(%esp), %eax  # stack load f310842
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310841
# emit-variable-ref
# env=((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310841
    movl -12(%esp), %eax  # stack load f310841
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=(if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))
# emit-expr (null? f310842)
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -16(%esp), %eax  # stack load f310842
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883754
# emit-tail-expr
# si=-24
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=f310841
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310841
    movl -20(%esp), %eax  # stack load f310841
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1883755
_L_1883754:
# emit-tail-expr
# si=-24
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
#    expr = (funcall (vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))
# emit-expr (vector-ref f310838 0)
# emit-expr f310838
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310838
    movl 2(%edi), %eax  # frame load f310838
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883756
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883756:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883757"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883757:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883759
    cmp  $0,%eax
    jge _L_1883758
_L_1883759:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883758:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f310842)
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -16(%esp), %eax  # stack load f310842
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883760
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883760:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f310842)
# emit-expr (cons (car f310842) f310841)
# cons arg1=(car f310842) arg2=f310841
# emit-expr (car f310842)
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -16(%esp), %eax  # stack load f310842
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883761
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883761:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
# emit-expr f310841
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310841
    movl -20(%esp), %eax  # stack load f310841
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (car f310842) f310841)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1883755:
    .align 4,0x90
_L_1883752:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310838 . 0))
# emit-expr (begin (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
# emit-begin
#   expr=(begin (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
#   env=((f310838 . 0))
# emit-expr (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))
# emit-closure
# si = -4
# env = ((f310838 . 0))
# expr = (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))
    movl $_L_1883762, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310838 . 0))
# var=f310838
    movl 0(%esp), %eax  # stack load f310838
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310838
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883763            # jump around closure body
_L_1883762:
# check argument count
    cmp $4,%eax
    je _L_1883764
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883764:
# emit-tail-expr
# si=-12
# env=((f310844 . -8) (f310838 . 4) (f310838 . 0))
# expr=(let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f310844 . -8) (f310838 . 4) (f310838 . 0))
#  bindings = ((f310844 f310844))
#  body = ((vector-ref f310838 0) f310844 ())
# emit-expr f310844
# emit-variable-ref
# env=((f310844 . -8) (f310838 . 4) (f310838 . 0))
# var=f310844
    movl -8(%esp), %eax  # stack load f310844
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310844 . -12) (f310844 . -8) (f310838 . 4) (f310838 . 0))
# expr=((vector-ref f310838 0) f310844 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f310844 . -12) (f310844 . -8) (f310838 . 4) (f310838 . 0))
#    expr = (funcall (vector-ref f310838 0) f310844 ())
# emit-expr (vector-ref f310838 0)
# emit-expr f310838
# emit-variable-ref
# env=((f310844 . -12) (f310844 . -8) (f310838 . 4) (f310838 . 0))
# var=f310838
    movl 2(%edi), %eax  # frame load f310838
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883765
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883765:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883766"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883766:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883768
    cmp  $0,%eax
    jge _L_1883767
_L_1883768:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883767:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310844
# emit-variable-ref
# env=((f310844 . -12) (f310844 . -8) (f310838 . 4) (f310838 . 0))
# var=f310844
    movl -12(%esp), %eax  # stack load f310844
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310844
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1883763:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310838 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (lambda args args)
# == eliminate-let*  ==>
# (lambda args args)
# == uniquify-variables  ==>
# (lambda f310845 f310845)
# == vectorize-letrec  ==>
# (lambda f310845 f310845)
# == eliminate-set!  ==>
# (lambda f310845 (let () f310845))
# == close-free-variables  ==>
# (closure f310845 () (let () f310845))
# == eliminate-quote  ==>
# (closure f310845 () (let () f310845))
# == eliminate-when/unless  ==>
# (closure f310845 () (let () f310845))
# == eliminate-cond  ==>
# (closure f310845 () (let () f310845))
# == external-symbols  ==>
# (closure f310845 () (let () f310845))
# emit-expr (closure f310845 () (let () f310845))
# emit-closure
# si = 0
# env = ()
# expr = (closure f310845 () (let () f310845))
    movl $_L_1883769, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883770            # jump around closure body
_L_1883769:
# check argument count
    cmp $0,%eax
    jge _L_1883771
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883771:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1883773:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1883772
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1883773
_L_1883772:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f310845 . -8))
# expr=(let () f310845)
# emit-tail-let
#  si   = -12
#  env  = ((f310845 . -8))
#  bindings = ()
#  body = f310845
# emit-tail-expr
# si=-12
# env=((f310845 . -8))
# expr=f310845
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310845 . -8))
# var=f310845
    movl -8(%esp), %eax  # stack load f310845
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1883770:
     movl %eax, mrc_list
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
# (letrec ((f310846 (lambda (f310852 f310851 f310850) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) (f310846 f310852 (fxadd1 f310851) (cdr f310850))))))) (lambda f310856 (let ((f310858 (make-vector (list-length f310856)))) (f310846 f310858 0 f310856))))
# == vectorize-letrec  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (lambda (f310852 f310851 f310850) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))) (lambda f310856 (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
# == eliminate-set!  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (lambda (f310852 f310851 f310850) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (lambda f310856 (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == close-free-variables  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == eliminate-quote  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == eliminate-when/unless  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == eliminate-cond  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == external-symbols  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# emit-expr (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310846 (make-vector 1)))
#  body = (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883774"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883774:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883775
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883775:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
# emit-begin
#   expr=(begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
#   env=((f310846 . 0))
# emit-expr (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))))
# emit-begin
#   expr=(begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))))
#   env=((f310846 . 0))
# emit-expr (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))
# emit-expr f310846
# emit-variable-ref
# env=((f310846 . 0))
# var=f310846
    movl 0(%esp), %eax  # stack load f310846
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883776
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883776:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883777"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883777:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883779
    cmp  $0,%eax
    jge _L_1883778
_L_1883779:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883778:
    movl %eax, -8(%esp)
# emit-expr (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))
# emit-closure
# si = -12
# env = ((f310846 . 0))
# expr = (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))
    movl $_L_1883780, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310846 . 0))
# var=f310846
    movl 0(%esp), %eax  # stack load f310846
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310846
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883781            # jump around closure body
_L_1883780:
# check argument count
    cmp $12,%eax
    je _L_1883782
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883782:
# emit-tail-expr
# si=-20
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))
# emit-tail-let
#  si   = -20
#  env  = ((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
#  bindings = ((f310852 f310852) (f310851 f310851) (f310850 f310850))
#  body = (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))
# emit-expr f310852
# emit-variable-ref
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -8(%esp), %eax  # stack load f310852
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f310851
# emit-variable-ref
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310851
    movl -12(%esp), %eax  # stack load f310851
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -16(%esp), %eax  # stack load f310850
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))
# emit-expr (null? f310850)
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -28(%esp), %eax  # stack load f310850
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883783
# emit-tail-expr
# si=-32
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=f310852
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -20(%esp), %eax  # stack load f310852
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1883784
_L_1883783:
# emit-tail-expr
# si=-32
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
# tail-begin (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
#   env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# emit-expr (vector-set! f310852 f310851 (car f310850))
# emit-expr f310852
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -20(%esp), %eax  # stack load f310852
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883785
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883785:
    movl %eax, -32(%esp)
# emit-expr f310851
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310851
    movl -24(%esp), %eax  # stack load f310851
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883786"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883786:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883788
    cmp  $0,%eax
    jge _L_1883787
_L_1883788:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883787:
    movl %eax, -36(%esp)
# emit-expr (car f310850)
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -28(%esp), %eax  # stack load f310850
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883789
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883789:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(begin ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
# tail-begin (begin ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
#   env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# emit-tail-expr
# si=-32
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))
# emit-tail-funcall
#    si   =-32
#    env  = ((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
#    expr = (funcall (vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))
# emit-expr (vector-ref f310846 0)
# emit-expr f310846
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310846
    movl 2(%edi), %eax  # frame load f310846
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883790
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883790:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883791"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883791:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883793
    cmp  $0,%eax
    jge _L_1883792
_L_1883793:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883792:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310852
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -20(%esp), %eax  # stack load f310852
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f310852
# emit-expr (fxadd1 f310851)
# emit-expr f310851
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310851
    movl -24(%esp), %eax  # stack load f310851
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883794"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883794:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f310851)
# emit-expr (cdr f310850)
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -28(%esp), %eax  # stack load f310850
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883795
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883795:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f310850)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1883784:
    .align 4,0x90
_L_1883781:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310846 . 0))
# emit-expr (begin (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
# emit-begin
#   expr=(begin (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
#   env=((f310846 . 0))
# emit-expr (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))
# emit-closure
# si = -4
# env = ((f310846 . 0))
# expr = (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))
    movl $_L_1883796, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310846 . 0))
# var=f310846
    movl 0(%esp), %eax  # stack load f310846
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310846
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883797            # jump around closure body
_L_1883796:
# check argument count
    cmp $0,%eax
    jge _L_1883798
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883798:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1883800:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1883799
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1883800
_L_1883799:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f310856 . -8) (f310846 . 4) (f310846 . 0))
# expr=(let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))
# emit-tail-let
#  si   = -12
#  env  = ((f310856 . -8) (f310846 . 4) (f310846 . 0))
#  bindings = ()
#  body = (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))
# emit-tail-expr
# si=-12
# env=((f310856 . -8) (f310846 . 4) (f310846 . 0))
# expr=(let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))
# emit-tail-let
#  si   = -12
#  env  = ((f310856 . -8) (f310846 . 4) (f310846 . 0))
#  bindings = ((f310858 (make-vector ((primitive-ref list-length) f310856))))
#  body = ((vector-ref f310846 0) f310858 0 f310856)
# emit-expr (make-vector ((primitive-ref list-length) f310856))
# make-vector ((primitive-ref list-length) f310856)
# emit-expr ((primitive-ref list-length) f310856)
# funcall
#    si   =-12
#    env  = ((f310856 . -8) (f310846 . 4) (f310846 . 0))
#    expr = (funcall (primitive-ref list-length) f310856)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883801"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883801":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f310856
# emit-variable-ref
# env=((f310856 . -8) (f310846 . 4) (f310846 . 0))
# var=f310856
    movl -8(%esp), %eax  # stack load f310856
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f310856
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883802"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883802:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883803
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883803:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310858 . -12) (f310856 . -8) (f310846 . 4) (f310846 . 0))
# expr=((vector-ref f310846 0) f310858 0 f310856)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310858 . -12) (f310856 . -8) (f310846 . 4) (f310846 . 0))
#    expr = (funcall (vector-ref f310846 0) f310858 0 f310856)
# emit-expr (vector-ref f310846 0)
# emit-expr f310846
# emit-variable-ref
# env=((f310858 . -12) (f310856 . -8) (f310846 . 4) (f310846 . 0))
# var=f310846
    movl 2(%edi), %eax  # frame load f310846
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883804
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883804:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883805"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883805:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883807
    cmp  $0,%eax
    jge _L_1883806
_L_1883807:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883806:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310858
# emit-variable-ref
# env=((f310858 . -12) (f310856 . -8) (f310846 . 4) (f310846 . 0))
# var=f310858
    movl -12(%esp), %eax  # stack load f310858
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310858
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f310856
# emit-variable-ref
# env=((f310858 . -12) (f310856 . -8) (f310846 . 4) (f310846 . 0))
# var=f310856
    movl -8(%esp), %eax  # stack load f310856
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310856
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1883797:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310846 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
# (letrec ((f310859 (lambda (f310865 f310864 f310863) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) (f310859 f310865 (fxadd1 f310864) (cdr f310863))))))) (lambda f310869 (let ((f310871 (make-string (list-length f310869)))) (f310859 f310871 0 f310869))))
# == vectorize-letrec  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (lambda (f310865 f310864 f310863) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))) (lambda f310869 (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
# == eliminate-set!  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (lambda (f310865 f310864 f310863) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (lambda f310869 (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == close-free-variables  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == eliminate-quote  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == eliminate-when/unless  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == eliminate-cond  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == external-symbols  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# emit-expr (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310859 (make-vector 1)))
#  body = (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883808"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883808:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883809
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883809:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
# emit-begin
#   expr=(begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
#   env=((f310859 . 0))
# emit-expr (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))))
# emit-begin
#   expr=(begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))))
#   env=((f310859 . 0))
# emit-expr (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))
# emit-expr f310859
# emit-variable-ref
# env=((f310859 . 0))
# var=f310859
    movl 0(%esp), %eax  # stack load f310859
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883810
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883810:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883811"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883811:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883813
    cmp  $0,%eax
    jge _L_1883812
_L_1883813:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883812:
    movl %eax, -8(%esp)
# emit-expr (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))
# emit-closure
# si = -12
# env = ((f310859 . 0))
# expr = (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))
    movl $_L_1883814, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310859 . 0))
# var=f310859
    movl 0(%esp), %eax  # stack load f310859
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310859
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883815            # jump around closure body
_L_1883814:
# check argument count
    cmp $12,%eax
    je _L_1883816
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883816:
# emit-tail-expr
# si=-20
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))
# emit-tail-let
#  si   = -20
#  env  = ((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
#  bindings = ((f310865 f310865) (f310864 f310864) (f310863 f310863))
#  body = (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))
# emit-expr f310865
# emit-variable-ref
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -8(%esp), %eax  # stack load f310865
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f310864
# emit-variable-ref
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310864
    movl -12(%esp), %eax  # stack load f310864
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -16(%esp), %eax  # stack load f310863
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))
# emit-expr (null? f310863)
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -28(%esp), %eax  # stack load f310863
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883817
# emit-tail-expr
# si=-32
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=f310865
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -20(%esp), %eax  # stack load f310865
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1883818
_L_1883817:
# emit-tail-expr
# si=-32
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
# tail-begin (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
#   env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# emit-expr (string-set! f310865 f310864 (car f310863))
# emit-expr f310865
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -20(%esp), %eax  # stack load f310865
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883819
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883819:
    movl %eax, -32(%esp)
# emit-expr f310864
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310864
    movl -24(%esp), %eax  # stack load f310864
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883820"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883820:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1883822
    cmp  $0,%eax
    jge _L_1883821
_L_1883822:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883821:
    movl %eax, -36(%esp)
# emit-expr (car f310863)
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -28(%esp), %eax  # stack load f310863
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883823
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883823:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1883824"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883824:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(begin ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
# tail-begin (begin ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
#   env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# emit-tail-expr
# si=-32
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))
# emit-tail-funcall
#    si   =-32
#    env  = ((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
#    expr = (funcall (vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))
# emit-expr (vector-ref f310859 0)
# emit-expr f310859
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310859
    movl 2(%edi), %eax  # frame load f310859
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883825
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883825:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883826"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883826:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883828
    cmp  $0,%eax
    jge _L_1883827
_L_1883828:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883827:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310865
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -20(%esp), %eax  # stack load f310865
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f310865
# emit-expr (fxadd1 f310864)
# emit-expr f310864
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310864
    movl -24(%esp), %eax  # stack load f310864
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883829"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883829:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f310864)
# emit-expr (cdr f310863)
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -28(%esp), %eax  # stack load f310863
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1883830
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883830:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f310863)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1883818:
    .align 4,0x90
_L_1883815:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310859 . 0))
# emit-expr (begin (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
# emit-begin
#   expr=(begin (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
#   env=((f310859 . 0))
# emit-expr (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))
# emit-closure
# si = -4
# env = ((f310859 . 0))
# expr = (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))
    movl $_L_1883831, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310859 . 0))
# var=f310859
    movl 0(%esp), %eax  # stack load f310859
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310859
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883832            # jump around closure body
_L_1883831:
# check argument count
    cmp $0,%eax
    jge _L_1883833
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883833:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1883835:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1883834
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1883835
_L_1883834:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f310869 . -8) (f310859 . 4) (f310859 . 0))
# expr=(let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))
# emit-tail-let
#  si   = -12
#  env  = ((f310869 . -8) (f310859 . 4) (f310859 . 0))
#  bindings = ()
#  body = (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))
# emit-tail-expr
# si=-12
# env=((f310869 . -8) (f310859 . 4) (f310859 . 0))
# expr=(let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))
# emit-tail-let
#  si   = -12
#  env  = ((f310869 . -8) (f310859 . 4) (f310859 . 0))
#  bindings = ((f310871 (make-string ((primitive-ref list-length) f310869))))
#  body = ((vector-ref f310859 0) f310871 0 f310869)
# emit-expr (make-string ((primitive-ref list-length) f310869))
# make-string len=((primitive-ref list-length) f310869)
# emit-expr ((primitive-ref list-length) f310869)
# funcall
#    si   =-12
#    env  = ((f310869 . -8) (f310859 . 4) (f310859 . 0))
#    expr = (funcall (primitive-ref list-length) f310869)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883836"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883836":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f310869
# emit-variable-ref
# env=((f310869 . -8) (f310859 . 4) (f310859 . 0))
# var=f310869
    movl -8(%esp), %eax  # stack load f310869
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f310869
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883837"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883837:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883838
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883838:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310871 . -12) (f310869 . -8) (f310859 . 4) (f310859 . 0))
# expr=((vector-ref f310859 0) f310871 0 f310869)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310871 . -12) (f310869 . -8) (f310859 . 4) (f310859 . 0))
#    expr = (funcall (vector-ref f310859 0) f310871 0 f310869)
# emit-expr (vector-ref f310859 0)
# emit-expr f310859
# emit-variable-ref
# env=((f310871 . -12) (f310869 . -8) (f310859 . 4) (f310859 . 0))
# var=f310859
    movl 2(%edi), %eax  # frame load f310859
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883839
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883839:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883840"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883840:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883842
    cmp  $0,%eax
    jge _L_1883841
_L_1883842:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883841:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310871
# emit-variable-ref
# env=((f310871 . -12) (f310869 . -8) (f310859 . 4) (f310859 . 0))
# var=f310871
    movl -12(%esp), %eax  # stack load f310871
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310871
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f310869
# emit-variable-ref
# env=((f310871 . -12) (f310869 . -8) (f310859 . 4) (f310859 . 0))
# var=f310869
    movl -8(%esp), %eax  # stack load f310869
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310869
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1883832:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310859 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
# (letrec ((f310872 (lambda (f310876 f310875) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) (f310872 f310876 (fxadd1 f310875))))))) (lambda (f310878) (f310872 f310878 0)))
# == vectorize-letrec  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (lambda (f310876 f310875) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))) (lambda (f310878) ((vector-ref f310872 0) f310878 0))))
# == eliminate-set!  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (lambda (f310876 f310875) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (lambda (f310878) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == close-free-variables  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == eliminate-quote  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == eliminate-when/unless  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == eliminate-cond  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == external-symbols  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# emit-expr (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310872 (make-vector 1)))
#  body = (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883843"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883843:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883844
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883844:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
#   env=((f310872 . 0))
# emit-expr (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))))
# emit-begin
#   expr=(begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))))
#   env=((f310872 . 0))
# emit-expr (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))
# emit-expr f310872
# emit-variable-ref
# env=((f310872 . 0))
# var=f310872
    movl 0(%esp), %eax  # stack load f310872
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883845
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883845:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883846"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883846:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883848
    cmp  $0,%eax
    jge _L_1883847
_L_1883848:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883847:
    movl %eax, -8(%esp)
# emit-expr (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))
# emit-closure
# si = -12
# env = ((f310872 . 0))
# expr = (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))
    movl $_L_1883849, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310872 . 0))
# var=f310872
    movl 0(%esp), %eax  # stack load f310872
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310872
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883850            # jump around closure body
_L_1883849:
# check argument count
    cmp $8,%eax
    je _L_1883851
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883851:
# emit-tail-expr
# si=-16
# env=((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# expr=(let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))
# emit-tail-let
#  si   = -16
#  env  = ((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
#  bindings = ((f310876 f310876) (f310875 f310875))
#  body = (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -8(%esp), %eax  # stack load f310876
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -12(%esp), %eax  # stack load f310875
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# expr=(if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))
# emit-expr (fx= f310875 (string-length f310876))
# emit-expr (string-length f310876)
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -16(%esp), %eax  # stack load f310876
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883854
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883854:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883855"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883855:
    movl %eax, -24(%esp)
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -20(%esp), %eax  # stack load f310875
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883856"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883856:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883852
# emit-tail-expr
# si=-24
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1883853
_L_1883852:
# emit-tail-expr
# si=-24
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# expr=(cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))
# tail primcall
# cons arg1=(string-ref f310876 f310875) arg2=((vector-ref f310872 0) f310876 (fxadd1 f310875))
# emit-expr (string-ref f310876 f310875)
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -16(%esp), %eax  # stack load f310876
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883857
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883857:
    movl %eax, -24(%esp)
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -20(%esp), %eax  # stack load f310875
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883858"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883858:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1883860
    cmp  $0,%eax
    jge _L_1883859
_L_1883860:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883859:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
# emit-expr ((vector-ref f310872 0) f310876 (fxadd1 f310875))
# funcall
#    si   =-28
#    env  = ((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
#    expr = (funcall (vector-ref f310872 0) f310876 (fxadd1 f310875))
# emit-expr (vector-ref f310872 0)
# emit-expr f310872
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310872
    movl 2(%edi), %eax  # frame load f310872
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883861
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883861:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883862"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883862:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883864
    cmp  $0,%eax
    jge _L_1883863
_L_1883864:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883863:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883865"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883865":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -16(%esp), %eax  # stack load f310876
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310876
# emit-expr (fxadd1 f310875)
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -20(%esp), %eax  # stack load f310875
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883866"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883866:
     addl $4, %eax
    mov %eax, -44(%esp)  # arg (fxadd1 f310875)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))
    ret
_L_1883853:
    .align 4,0x90
_L_1883850:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310872 . 0))
# emit-expr (begin (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
# emit-begin
#   expr=(begin (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
#   env=((f310872 . 0))
# emit-expr (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))
# emit-closure
# si = -4
# env = ((f310872 . 0))
# expr = (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))
    movl $_L_1883867, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310872 . 0))
# var=f310872
    movl 0(%esp), %eax  # stack load f310872
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310872
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883868            # jump around closure body
_L_1883867:
# check argument count
    cmp $4,%eax
    je _L_1883869
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883869:
# emit-tail-expr
# si=-12
# env=((f310878 . -8) (f310872 . 4) (f310872 . 0))
# expr=(let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))
# emit-tail-let
#  si   = -12
#  env  = ((f310878 . -8) (f310872 . 4) (f310872 . 0))
#  bindings = ((f310878 f310878))
#  body = ((vector-ref f310872 0) f310878 0)
# emit-expr f310878
# emit-variable-ref
# env=((f310878 . -8) (f310872 . 4) (f310872 . 0))
# var=f310878
    movl -8(%esp), %eax  # stack load f310878
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310878 . -12) (f310878 . -8) (f310872 . 4) (f310872 . 0))
# expr=((vector-ref f310872 0) f310878 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310878 . -12) (f310878 . -8) (f310872 . 4) (f310872 . 0))
#    expr = (funcall (vector-ref f310872 0) f310878 0)
# emit-expr (vector-ref f310872 0)
# emit-expr f310872
# emit-variable-ref
# env=((f310878 . -12) (f310878 . -8) (f310872 . 4) (f310872 . 0))
# var=f310872
    movl 2(%edi), %eax  # frame load f310872
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883870
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883870:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883871"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883871:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883873
    cmp  $0,%eax
    jge _L_1883872
_L_1883873:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883872:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310878
# emit-variable-ref
# env=((f310878 . -12) (f310878 . -8) (f310872 . 4) (f310872 . 0))
# var=f310878
    movl -12(%esp), %eax  # stack load f310878
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310878
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1883868:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310872 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f310879 (lambda (f310883 f310882) (cond ((fx< f310883 10) (cons f310883 f310882)) (else (f310879 (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (lambda (f310885) (f310879 f310885 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (lambda (f310883 f310882) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (lambda (f310885) ((vector-ref f310879 0) f310885 (quote ())))))
# == eliminate-set!  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (lambda (f310883 f310882) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (lambda (f310885) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 (quote ()))))))
# == close-free-variables  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# == eliminate-when/unless  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# == eliminate-cond  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# == external-symbols  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# emit-expr (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310879 (make-vector 1)))
#  body = (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883874"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883874:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1883875
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883875:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
#   env=((f310879 . 0))
# emit-expr (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))
# emit-begin
#   expr=(begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))
#   env=((f310879 . 0))
# emit-expr (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))
# emit-expr f310879
# emit-variable-ref
# env=((f310879 . 0))
# var=f310879
    movl 0(%esp), %eax  # stack load f310879
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883876
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883876:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883877"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883877:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883879
    cmp  $0,%eax
    jge _L_1883878
_L_1883879:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883878:
    movl %eax, -8(%esp)
# emit-expr (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))
# emit-closure
# si = -12
# env = ((f310879 . 0))
# expr = (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))
    movl $_L_1883880, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310879 . 0))
# var=f310879
    movl 0(%esp), %eax  # stack load f310879
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310879
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883881            # jump around closure body
_L_1883880:
# check argument count
    cmp $8,%eax
    je _L_1883882
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883882:
# emit-tail-expr
# si=-16
# env=((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=(let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))
# emit-tail-let
#  si   = -16
#  env  = ((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
#  bindings = ((f310883 f310883) (f310882 f310882))
#  body = (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -8(%esp), %eax  # stack load f310883
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310882
# emit-variable-ref
# env=((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310882
    movl -12(%esp), %eax  # stack load f310882
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=(if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))
# emit-expr (fx< f310883 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883885"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883885:
    movl %eax, -24(%esp)
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883886"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883886:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1883883
# emit-tail-expr
# si=-24
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=(cons f310883 f310882)
# tail primcall
# cons arg1=f310883 arg2=f310882
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f310882
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310882
    movl -20(%esp), %eax  # stack load f310882
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f310883 f310882)
    ret
    jmp _L_1883884
_L_1883883:
# emit-tail-expr
# si=-24
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
#    expr = (funcall (vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))
# emit-expr (vector-ref f310879 0)
# emit-expr f310879
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310879
    movl 2(%edi), %eax  # frame load f310879
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883887
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883887:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883888"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883888:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883890
    cmp  $0,%eax
    jge _L_1883889
_L_1883890:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883889:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fxquotient f310883 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883892"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883892:
    movl %eax, -28(%esp)  # denominator
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883893"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883893:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1883891
    not %edx
_L_1883891:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
    mov %eax, -28(%esp)    # arg (fxquotient f310883 10)
# emit-expr (cons (fxremainder f310883 10) f310882)
# cons arg1=(fxremainder f310883 10) arg2=f310882
# emit-expr (fxremainder f310883 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883895"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883895:
    movl %eax, -32(%esp)  # denominator
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883896"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883896:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1883894
    not %edx
_L_1883894:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
# emit-expr f310882
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310882
    movl -20(%esp), %eax  # stack load f310882
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (fxremainder f310883 10) f310882)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1883884:
    .align 4,0x90
_L_1883881:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310879 . 0))
# emit-expr (begin (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
# emit-begin
#   expr=(begin (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
#   env=((f310879 . 0))
# emit-expr (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))
# emit-closure
# si = -4
# env = ((f310879 . 0))
# expr = (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))
    movl $_L_1883897, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310879 . 0))
# var=f310879
    movl 0(%esp), %eax  # stack load f310879
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310879
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883898            # jump around closure body
_L_1883897:
# check argument count
    cmp $4,%eax
    je _L_1883899
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883899:
# emit-tail-expr
# si=-12
# env=((f310885 . -8) (f310879 . 4) (f310879 . 0))
# expr=(let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f310885 . -8) (f310879 . 4) (f310879 . 0))
#  bindings = ((f310885 f310885))
#  body = ((vector-ref f310879 0) f310885 ())
# emit-expr f310885
# emit-variable-ref
# env=((f310885 . -8) (f310879 . 4) (f310879 . 0))
# var=f310885
    movl -8(%esp), %eax  # stack load f310885
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310885 . -12) (f310885 . -8) (f310879 . 4) (f310879 . 0))
# expr=((vector-ref f310879 0) f310885 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f310885 . -12) (f310885 . -8) (f310879 . 4) (f310879 . 0))
#    expr = (funcall (vector-ref f310879 0) f310885 ())
# emit-expr (vector-ref f310879 0)
# emit-expr f310879
# emit-variable-ref
# env=((f310885 . -12) (f310885 . -8) (f310879 . 4) (f310879 . 0))
# var=f310879
    movl 2(%edi), %eax  # frame load f310879
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883900
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883900:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883901"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883901:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883903
    cmp  $0,%eax
    jge _L_1883902
_L_1883903:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883902:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310885
# emit-variable-ref
# env=((f310885 . -12) (f310885 . -8) (f310879 . 4) (f310879 . 0))
# var=f310885
    movl -12(%esp), %eax  # stack load f310885
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310885
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1883898:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310879 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
# (let ((f310886 (lambda (f310887) (foreign-call "s_write" 2 f310887 (string-length f310887))))) (let ((f310895 (lambda (f310897 f310896) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))) (lambda (f310901 f310900) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f310886 (lambda (f310887) (foreign-call "s_write" 2 f310887 (string-length f310887))))) (let ((f310895 (lambda (f310897 f310896) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))) (lambda (f310901 f310900) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f310886 (lambda (f310887) (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (lambda (f310897 f310896) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (lambda (f310901 f310900) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887))))))
#  body = (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887))))
    movl $_L_1883904, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883905            # jump around closure body
_L_1883904:
# check argument count
    cmp $4,%eax
    je _L_1883906
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883906:
# emit-tail-expr
# si=-12
# env=((f310887 . -8))
# expr=(let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))
# emit-tail-let
#  si   = -12
#  env  = ((f310887 . -8))
#  bindings = ((f310887 f310887))
#  body = (foreign-call "s_write" 2 f310887 (string-length f310887))
# emit-expr f310887
# emit-variable-ref
# env=((f310887 . -8))
# var=f310887
    movl -8(%esp), %eax  # stack load f310887
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310887 . -12) (f310887 . -8))
# expr=(foreign-call "s_write" 2 f310887 (string-length f310887))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f310887)
# emit-expr f310887
# emit-variable-ref
# env=((f310887 . -12) (f310887 . -8))
# var=f310887
    movl -12(%esp), %eax  # stack load f310887
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1883907
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883907:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f310887
# emit-variable-ref
# env=((f310887 . -12) (f310887 . -8))
# var=f310887
    movl -12(%esp), %eax  # stack load f310887
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_1883905:
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f310886 . 0))
#  bindings = ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))))
#  body = (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))
# emit-expr (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))
# emit-closure
# si = -4
# env = ((f310886 . 0))
# expr = (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))
    movl $_L_1883908, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310886 . 0))
# var=f310886
    movl 0(%esp), %eax  # stack load f310886
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310886
# emit-variable-ref
# env=((f310886 . 0))
# var=f310886
    movl 0(%esp), %eax  # stack load f310886
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f310886
# emit-variable-ref
# env=((f310886 . 0))
# var=f310886
    movl 0(%esp), %eax  # stack load f310886
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f310886
# emit-variable-ref
# env=((f310886 . 0))
# var=f310886
    movl 0(%esp), %eax  # stack load f310886
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f310886
# emit-variable-ref
# env=((f310886 . 0))
# var=f310886
    movl 0(%esp), %eax  # stack load f310886
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f310886
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1883909            # jump around closure body
_L_1883908:
# check argument count
    cmp $8,%eax
    je _L_1883910
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883910:
# emit-tail-expr
# si=-16
# env=((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#  bindings = ((f310897 f310897) (f310896 f310896))
#  body = (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# emit-expr f310897
# emit-variable-ref
# env=((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310897
    movl -8(%esp), %eax  # stack load f310897
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310896
# emit-variable-ref
# env=((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310896
    movl -12(%esp), %eax  # stack load f310896
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 "error:")
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 "error:")
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883911"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883911":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_1883913
    .align 8,0x90
_L_1883912 :
    .int 24
    .ascii "error:"
_L_1883913:
    movl $_L_1883912, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 (symbol->string f310897))
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 (symbol->string f310897))
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883914"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883914":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (symbol->string f310897)
# symbol->string f310897
# emit-expr f310897
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310897
    movl -16(%esp), %eax  # stack load f310897
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f310897)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 ": ") (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 ": ")
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 ": ")
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883915"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883915":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_1883917
    .align 8,0x90
_L_1883916 :
    .int 8
    .ascii ": "
_L_1883917:
    movl $_L_1883916, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 f310896)
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 f310896)
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883918"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883918":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310896
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310896
    movl -20(%esp), %eax  # stack load f310896
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310896
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 "\n"))
# tail-begin (begin (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-tail-expr
# si=-24
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(f310886 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 "\n")
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_1883920
    .align 8,0x90
_L_1883919 :
    .int 4
    .ascii "\n"
_L_1883920:
    movl $_L_1883919, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1883909:
    movl %eax, -4(%esp)  # stack save
# emit-expr (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f310895 . -4) (f310886 . 0))
# expr = (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))
    movl $_L_1883921, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310895 . -4) (f310886 . 0))
# var=f310895
    movl -4(%esp), %eax  # stack load f310895
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310895
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1883922            # jump around closure body
_L_1883921:
# check argument count
    cmp $8,%eax
    je _L_1883923
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1883923:
# emit-tail-expr
# si=-16
# env=((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# expr=(let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
#  bindings = ((f310901 f310901) (f310900 f310900))
#  body = (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))
# emit-expr f310901
# emit-variable-ref
# env=((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310901
    movl -8(%esp), %eax  # stack load f310901
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310900
# emit-variable-ref
# env=((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310900
    movl -12(%esp), %eax  # stack load f310900
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# expr=(begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))
# tail-begin (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))
#   env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# emit-expr (f310895 f310901 f310900)
# funcall
#    si   =-24
#    env  = ((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
#    expr = (funcall f310895 f310901 f310900)
# emit-expr f310895
# emit-variable-ref
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310895
    movl 2(%edi), %eax  # frame load f310895
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883924"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883924":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310901
# emit-variable-ref
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310901
    movl -16(%esp), %eax  # stack load f310901
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310901
# emit-expr f310900
# emit-variable-ref
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310900
    movl -20(%esp), %eax  # stack load f310900
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310900
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# emit-tail-expr
# si=-24
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1883922:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f310902 (quote ()))) (begin (set! f310902 (cons (quote procedure?) f310902)) (set! f310902 (cons (quote cdr) f310902)) (set! f310902 (cons (quote car) f310902)) (set! f310902 (cons (quote symbol-value) f310902)) (set! f310902 (cons (quote symbol->string) f310902)) (set! f310902 (cons (quote make-symbol) f310902)) (set! f310902 (cons (quote symbol?) f310902)) (set! f310902 (cons (quote string-set!) f310902)) (set! f310902 (cons (quote string-ref) f310902)) (set! f310902 (cons (quote string-length) f310902)) (set! f310902 (cons (quote string?) f310902)) (set! f310902 (cons (quote make-string) f310902)) (set! f310902 (cons (quote vector-ref) f310902)) (set! f310902 (cons (quote vector-set!) f310902)) (set! f310902 (cons (quote vector-length) f310902)) (set! f310902 (cons (quote make-vector) f310902)) (set! f310902 (cons (quote vector?) f310902)) (set! f310902 (cons (quote set-cdr!) f310902)) (set! f310902 (cons (quote set-car!) f310902)) (set! f310902 (cons (quote cdr) f310902)) (set! f310902 (cons (quote car) f310902)) (set! f310902 (cons (quote cons) f310902)) (set! f310902 (cons (quote pair?) f310902)) (set! f310902 (cons (quote fxremainder) f310902)) (set! f310902 (cons (quote fxquotient) f310902)) (set! f310902 (cons (quote fx*) f310902)) (set! f310902 (cons (quote fx-) f310902)) (set! f310902 (cons (quote fx+) f310902)) (set! f310902 (cons (quote fx>=) f310902)) (set! f310902 (cons (quote fx>) f310902)) (set! f310902 (cons (quote fx<=) f310902)) (set! f310902 (cons (quote fx<) f310902)) (set! f310902 (cons (quote fx=) f310902)) (set! f310902 (cons (quote fxzero?) f310902)) (set! f310902 (cons (quote fxsub1) f310902)) (set! f310902 (cons (quote fxadd1) f310902)) (set! f310902 (cons (quote fxlogor) f310902)) (set! f310902 (cons (quote fxlogand) f310902)) (set! f310902 (cons (quote fxlognot) f310902)) (set! f310902 (cons (quote char=?) f310902)) (set! f310902 (cons (quote eq?) f310902)) (set! f310902 (cons (quote not) f310902)) (set! f310902 (cons (quote boolean?) f310902)) (set! f310902 (cons (quote fixnum?) f310902)) (set! f310902 (cons (quote char?) f310902)) (set! f310902 (cons (quote eof-object) f310902)) (set! f310902 (cons (quote eof-object?) f310902)) (set! f310902 (cons (quote null?) f310902)) (set! f310902 (cons (quote char->fixnum) f310902)) (set! f310902 (cons (quote fixnum->char) f310902)) (lambda () f310902)))
# == vectorize-letrec  ==>
# (let ((f310902 (quote ()))) (begin (set! f310902 (cons (quote procedure?) f310902)) (set! f310902 (cons (quote cdr) f310902)) (set! f310902 (cons (quote car) f310902)) (set! f310902 (cons (quote symbol-value) f310902)) (set! f310902 (cons (quote symbol->string) f310902)) (set! f310902 (cons (quote make-symbol) f310902)) (set! f310902 (cons (quote symbol?) f310902)) (set! f310902 (cons (quote string-set!) f310902)) (set! f310902 (cons (quote string-ref) f310902)) (set! f310902 (cons (quote string-length) f310902)) (set! f310902 (cons (quote string?) f310902)) (set! f310902 (cons (quote make-string) f310902)) (set! f310902 (cons (quote vector-ref) f310902)) (set! f310902 (cons (quote vector-set!) f310902)) (set! f310902 (cons (quote vector-length) f310902)) (set! f310902 (cons (quote make-vector) f310902)) (set! f310902 (cons (quote vector?) f310902)) (set! f310902 (cons (quote set-cdr!) f310902)) (set! f310902 (cons (quote set-car!) f310902)) (set! f310902 (cons (quote cdr) f310902)) (set! f310902 (cons (quote car) f310902)) (set! f310902 (cons (quote cons) f310902)) (set! f310902 (cons (quote pair?) f310902)) (set! f310902 (cons (quote fxremainder) f310902)) (set! f310902 (cons (quote fxquotient) f310902)) (set! f310902 (cons (quote fx*) f310902)) (set! f310902 (cons (quote fx-) f310902)) (set! f310902 (cons (quote fx+) f310902)) (set! f310902 (cons (quote fx>=) f310902)) (set! f310902 (cons (quote fx>) f310902)) (set! f310902 (cons (quote fx<=) f310902)) (set! f310902 (cons (quote fx<) f310902)) (set! f310902 (cons (quote fx=) f310902)) (set! f310902 (cons (quote fxzero?) f310902)) (set! f310902 (cons (quote fxsub1) f310902)) (set! f310902 (cons (quote fxadd1) f310902)) (set! f310902 (cons (quote fxlogor) f310902)) (set! f310902 (cons (quote fxlogand) f310902)) (set! f310902 (cons (quote fxlognot) f310902)) (set! f310902 (cons (quote char=?) f310902)) (set! f310902 (cons (quote eq?) f310902)) (set! f310902 (cons (quote not) f310902)) (set! f310902 (cons (quote boolean?) f310902)) (set! f310902 (cons (quote fixnum?) f310902)) (set! f310902 (cons (quote char?) f310902)) (set! f310902 (cons (quote eof-object) f310902)) (set! f310902 (cons (quote eof-object?) f310902)) (set! f310902 (cons (quote null?) f310902)) (set! f310902 (cons (quote char->fixnum) f310902)) (set! f310902 (cons (quote fixnum->char) f310902)) (lambda () f310902)))
# == eliminate-set!  ==>
# (let ((f310902 (vector (quote ())))) (begin (vector-set! f310902 0 (cons (quote procedure?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote cdr) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote car) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote symbol-value) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote symbol->string) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote make-symbol) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote symbol?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string-set!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string-ref) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string-length) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote make-string) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector-ref) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector-set!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector-length) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote make-vector) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote set-cdr!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote set-car!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote cdr) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote car) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote cons) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote pair?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxremainder) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxquotient) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx*) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx-) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx+) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx>=) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx>) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx<=) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx<) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx=) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxzero?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxsub1) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxadd1) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxlogor) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxlogand) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxlognot) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote char=?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote eq?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote not) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote boolean?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fixnum?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote char?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote eof-object) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote eof-object?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote null?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote char->fixnum) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fixnum->char) (vector-ref f310902 0))) (lambda () (let () (vector-ref f310902 0)))))
# == close-free-variables  ==>
# (let ((f310902 (vector (quote ())))) (begin (vector-set! f310902 0 (cons (quote procedure?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote cdr) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote car) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote symbol-value) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote symbol->string) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote make-symbol) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote symbol?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string-set!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string-ref) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string-length) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote string?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote make-string) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector-ref) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector-set!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector-length) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote make-vector) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote vector?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote set-cdr!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote set-car!) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote cdr) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote car) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote cons) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote pair?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxremainder) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxquotient) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx*) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx-) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx+) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx>=) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx>) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx<=) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx<) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fx=) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxzero?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxsub1) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxadd1) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxlogor) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxlogand) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fxlognot) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote char=?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote eq?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote not) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote boolean?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fixnum?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote char?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote eof-object) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote eof-object?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote null?) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote char->fixnum) (vector-ref f310902 0))) (vector-set! f310902 0 (cons (quote fixnum->char) (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0)))))
# == eliminate-quote  ==>
# (let ((f310902 (vector ()))) (begin (vector-set! f310902 0 (cons (string->symbol "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0)))))
# == eliminate-when/unless  ==>
# (let ((f310902 (vector ()))) (begin (vector-set! f310902 0 (cons (string->symbol "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0)))))
# == eliminate-cond  ==>
# (let ((f310902 (vector ()))) (begin (vector-set! f310902 0 (cons (string->symbol "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons (string->symbol "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0)))))
# == external-symbols  ==>
# (let ((f310902 ((primitive-ref vector) ()))) (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0)))))
# emit-expr (let ((f310902 ((primitive-ref vector) ()))) (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310902 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883925"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883925":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883926
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883926:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883927"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883927:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883929
    cmp  $0,%eax
    jge _L_1883928
_L_1883929:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883928:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883930"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883930":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_1883932
    .align 8,0x90
_L_1883931 :
    .int 40
    .ascii "procedure?"
_L_1883932:
    movl $_L_1883931, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883933
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883933:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883934"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883934:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883936
    cmp  $0,%eax
    jge _L_1883935
_L_1883936:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883935:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883937
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883937:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883938"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883938:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883940
    cmp  $0,%eax
    jge _L_1883939
_L_1883940:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883939:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883941"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883941":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1883943
    .align 8,0x90
_L_1883942 :
    .int 12
    .ascii "cdr"
_L_1883943:
    movl $_L_1883942, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883944
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883944:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883945"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883945:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883947
    cmp  $0,%eax
    jge _L_1883946
_L_1883947:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883946:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883948
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883948:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883949"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883949:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883951
    cmp  $0,%eax
    jge _L_1883950
_L_1883951:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883950:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883952"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883952":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1883954
    .align 8,0x90
_L_1883953 :
    .int 12
    .ascii "car"
_L_1883954:
    movl $_L_1883953, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883955
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883955:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883956"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883956:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883958
    cmp  $0,%eax
    jge _L_1883957
_L_1883958:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883957:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883959
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883959:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883960"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883960:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883962
    cmp  $0,%eax
    jge _L_1883961
_L_1883962:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883961:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883963"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883963":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_1883965
    .align 8,0x90
_L_1883964 :
    .int 48
    .ascii "symbol-value"
_L_1883965:
    movl $_L_1883964, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883966
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883966:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883967"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883967:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883969
    cmp  $0,%eax
    jge _L_1883968
_L_1883969:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883968:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883970
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883970:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883971"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883971:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883973
    cmp  $0,%eax
    jge _L_1883972
_L_1883973:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883972:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883974"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883974":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_1883976
    .align 8,0x90
_L_1883975 :
    .int 56
    .ascii "symbol->string"
_L_1883976:
    movl $_L_1883975, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883977
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883977:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883978"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883978:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883980
    cmp  $0,%eax
    jge _L_1883979
_L_1883980:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883979:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883981
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883981:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883982"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883982:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883984
    cmp  $0,%eax
    jge _L_1883983
_L_1883984:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883983:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883985"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883985":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_1883987
    .align 8,0x90
_L_1883986 :
    .int 44
    .ascii "make-symbol"
_L_1883987:
    movl $_L_1883986, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883988
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883988:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883989"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883989:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883991
    cmp  $0,%eax
    jge _L_1883990
_L_1883991:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883990:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883992
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883992:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1883993"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883993:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1883995
    cmp  $0,%eax
    jge _L_1883994
_L_1883995:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1883994:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1883996"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1883996":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_1883998
    .align 8,0x90
_L_1883997 :
    .int 28
    .ascii "symbol?"
_L_1883998:
    movl $_L_1883997, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1883999
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1883999:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884000"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884000:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884002
    cmp  $0,%eax
    jge _L_1884001
_L_1884002:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884001:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884003
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884003:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884004"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884004:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884006
    cmp  $0,%eax
    jge _L_1884005
_L_1884006:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884005:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884007"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884007":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_1884009
    .align 8,0x90
_L_1884008 :
    .int 44
    .ascii "string-set!"
_L_1884009:
    movl $_L_1884008, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884010
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884010:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884011"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884011:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884013
    cmp  $0,%eax
    jge _L_1884012
_L_1884013:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884012:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884014
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884014:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884015"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884015:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884017
    cmp  $0,%eax
    jge _L_1884016
_L_1884017:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884016:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884018"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884018":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_1884020
    .align 8,0x90
_L_1884019 :
    .int 40
    .ascii "string-ref"
_L_1884020:
    movl $_L_1884019, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884021
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884021:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884022"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884022:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884024
    cmp  $0,%eax
    jge _L_1884023
_L_1884024:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884023:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884025
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884025:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884026"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884026:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884028
    cmp  $0,%eax
    jge _L_1884027
_L_1884028:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884027:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884029"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884029":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_1884031
    .align 8,0x90
_L_1884030 :
    .int 52
    .ascii "string-length"
_L_1884031:
    movl $_L_1884030, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884032
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884032:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884033"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884033:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884035
    cmp  $0,%eax
    jge _L_1884034
_L_1884035:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884034:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884036
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884036:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884037"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884037:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884039
    cmp  $0,%eax
    jge _L_1884038
_L_1884039:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884038:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884040"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884040":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_1884042
    .align 8,0x90
_L_1884041 :
    .int 28
    .ascii "string?"
_L_1884042:
    movl $_L_1884041, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884043
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884043:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884044"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884044:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884046
    cmp  $0,%eax
    jge _L_1884045
_L_1884046:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884045:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884047
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884047:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884048"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884048:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884050
    cmp  $0,%eax
    jge _L_1884049
_L_1884050:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884049:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884051"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884051":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_1884053
    .align 8,0x90
_L_1884052 :
    .int 44
    .ascii "make-string"
_L_1884053:
    movl $_L_1884052, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884054
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884054:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884055"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884055:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884057
    cmp  $0,%eax
    jge _L_1884056
_L_1884057:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884056:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884058
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884058:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884059"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884059:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884061
    cmp  $0,%eax
    jge _L_1884060
_L_1884061:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884060:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884062"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884062":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_1884064
    .align 8,0x90
_L_1884063 :
    .int 40
    .ascii "vector-ref"
_L_1884064:
    movl $_L_1884063, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884065
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884065:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884066"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884066:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884068
    cmp  $0,%eax
    jge _L_1884067
_L_1884068:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884067:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884069
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884069:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884070"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884070:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884072
    cmp  $0,%eax
    jge _L_1884071
_L_1884072:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884071:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884073"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884073":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_1884075
    .align 8,0x90
_L_1884074 :
    .int 44
    .ascii "vector-set!"
_L_1884075:
    movl $_L_1884074, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884076
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884076:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884077"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884077:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884079
    cmp  $0,%eax
    jge _L_1884078
_L_1884079:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884078:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884080
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884080:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884081"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884081:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884083
    cmp  $0,%eax
    jge _L_1884082
_L_1884083:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884082:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884084"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884084":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_1884086
    .align 8,0x90
_L_1884085 :
    .int 52
    .ascii "vector-length"
_L_1884086:
    movl $_L_1884085, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884087
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884087:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884088"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884088:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884090
    cmp  $0,%eax
    jge _L_1884089
_L_1884090:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884089:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884091
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884091:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884092"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884092:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884094
    cmp  $0,%eax
    jge _L_1884093
_L_1884094:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884093:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884095"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884095":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_1884097
    .align 8,0x90
_L_1884096 :
    .int 44
    .ascii "make-vector"
_L_1884097:
    movl $_L_1884096, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884098
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884098:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884099"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884099:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884101
    cmp  $0,%eax
    jge _L_1884100
_L_1884101:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884100:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884102
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884102:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884103"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884103:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884105
    cmp  $0,%eax
    jge _L_1884104
_L_1884105:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884104:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884106"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884106":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_1884108
    .align 8,0x90
_L_1884107 :
    .int 28
    .ascii "vector?"
_L_1884108:
    movl $_L_1884107, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884109
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884109:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884110"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884110:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884112
    cmp  $0,%eax
    jge _L_1884111
_L_1884112:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884111:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884113
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884113:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884114"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884114:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884116
    cmp  $0,%eax
    jge _L_1884115
_L_1884116:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884115:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884117"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884117":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_1884119
    .align 8,0x90
_L_1884118 :
    .int 32
    .ascii "set-cdr!"
_L_1884119:
    movl $_L_1884118, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884120
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884120:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884121"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884121:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884123
    cmp  $0,%eax
    jge _L_1884122
_L_1884123:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884122:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884124
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884124:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884125"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884125:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884127
    cmp  $0,%eax
    jge _L_1884126
_L_1884127:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884126:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884128"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884128":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_1884130
    .align 8,0x90
_L_1884129 :
    .int 32
    .ascii "set-car!"
_L_1884130:
    movl $_L_1884129, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884131
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884131:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884132"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884132:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884134
    cmp  $0,%eax
    jge _L_1884133
_L_1884134:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884133:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884135
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884135:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884136"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884136:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884138
    cmp  $0,%eax
    jge _L_1884137
_L_1884138:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884137:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884139"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884139":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1884141
    .align 8,0x90
_L_1884140 :
    .int 12
    .ascii "cdr"
_L_1884141:
    movl $_L_1884140, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884142
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884142:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884143"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884143:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884145
    cmp  $0,%eax
    jge _L_1884144
_L_1884145:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884144:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884146
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884146:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884147"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884147:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884149
    cmp  $0,%eax
    jge _L_1884148
_L_1884149:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884148:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884150"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884150":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1884152
    .align 8,0x90
_L_1884151 :
    .int 12
    .ascii "car"
_L_1884152:
    movl $_L_1884151, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884153
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884153:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884154"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884154:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884156
    cmp  $0,%eax
    jge _L_1884155
_L_1884156:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884155:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884157
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884157:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884158"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884158:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884160
    cmp  $0,%eax
    jge _L_1884159
_L_1884160:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884159:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884161"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884161":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_1884163
    .align 8,0x90
_L_1884162 :
    .int 16
    .ascii "cons"
_L_1884163:
    movl $_L_1884162, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884164
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884164:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884165"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884165:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884167
    cmp  $0,%eax
    jge _L_1884166
_L_1884167:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884166:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884168
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884168:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884169"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884169:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884171
    cmp  $0,%eax
    jge _L_1884170
_L_1884171:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884170:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884172"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884172":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_1884174
    .align 8,0x90
_L_1884173 :
    .int 20
    .ascii "pair?"
_L_1884174:
    movl $_L_1884173, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884175
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884175:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884176"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884176:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884178
    cmp  $0,%eax
    jge _L_1884177
_L_1884178:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884177:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884179
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884179:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884180"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884180:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884182
    cmp  $0,%eax
    jge _L_1884181
_L_1884182:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884181:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884183"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884183":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_1884185
    .align 8,0x90
_L_1884184 :
    .int 44
    .ascii "fxremainder"
_L_1884185:
    movl $_L_1884184, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884186
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884186:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884187"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884187:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884189
    cmp  $0,%eax
    jge _L_1884188
_L_1884189:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884188:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884190
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884190:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884191"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884191:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884193
    cmp  $0,%eax
    jge _L_1884192
_L_1884193:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884192:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884194"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884194":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_1884196
    .align 8,0x90
_L_1884195 :
    .int 40
    .ascii "fxquotient"
_L_1884196:
    movl $_L_1884195, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884197
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884197:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884198"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884198:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884200
    cmp  $0,%eax
    jge _L_1884199
_L_1884200:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884199:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884201
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884201:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884202"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884202:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884204
    cmp  $0,%eax
    jge _L_1884203
_L_1884204:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884203:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884205"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884205":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_1884207
    .align 8,0x90
_L_1884206 :
    .int 12
    .ascii "fx*"
_L_1884207:
    movl $_L_1884206, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884208
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884208:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884209"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884209:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884211
    cmp  $0,%eax
    jge _L_1884210
_L_1884211:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884210:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884212
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884212:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884213"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884213:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884215
    cmp  $0,%eax
    jge _L_1884214
_L_1884215:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884214:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884216"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884216":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_1884218
    .align 8,0x90
_L_1884217 :
    .int 12
    .ascii "fx-"
_L_1884218:
    movl $_L_1884217, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884219
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884219:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884220"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884220:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884222
    cmp  $0,%eax
    jge _L_1884221
_L_1884222:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884221:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884223
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884223:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884224"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884224:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884226
    cmp  $0,%eax
    jge _L_1884225
_L_1884226:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884225:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884227"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884227":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_1884229
    .align 8,0x90
_L_1884228 :
    .int 12
    .ascii "fx+"
_L_1884229:
    movl $_L_1884228, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884230
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884230:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884231"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884231:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884233
    cmp  $0,%eax
    jge _L_1884232
_L_1884233:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884232:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884234
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884234:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884235"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884235:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884237
    cmp  $0,%eax
    jge _L_1884236
_L_1884237:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884236:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884238"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884238":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_1884240
    .align 8,0x90
_L_1884239 :
    .int 16
    .ascii "fx>="
_L_1884240:
    movl $_L_1884239, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884241
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884241:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884242"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884242:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884244
    cmp  $0,%eax
    jge _L_1884243
_L_1884244:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884243:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884245
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884245:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884246"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884246:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884248
    cmp  $0,%eax
    jge _L_1884247
_L_1884248:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884247:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884249"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884249":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_1884251
    .align 8,0x90
_L_1884250 :
    .int 12
    .ascii "fx>"
_L_1884251:
    movl $_L_1884250, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884252
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884252:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884253"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884253:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884255
    cmp  $0,%eax
    jge _L_1884254
_L_1884255:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884254:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884256
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884256:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884257"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884257:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884259
    cmp  $0,%eax
    jge _L_1884258
_L_1884259:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884258:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884260"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884260":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_1884262
    .align 8,0x90
_L_1884261 :
    .int 16
    .ascii "fx<="
_L_1884262:
    movl $_L_1884261, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884263
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884263:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884264"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884264:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884266
    cmp  $0,%eax
    jge _L_1884265
_L_1884266:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884265:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884267
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884267:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884268"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884268:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884270
    cmp  $0,%eax
    jge _L_1884269
_L_1884270:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884269:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884271"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884271":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_1884273
    .align 8,0x90
_L_1884272 :
    .int 12
    .ascii "fx<"
_L_1884273:
    movl $_L_1884272, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884274
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884274:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884275"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884275:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884277
    cmp  $0,%eax
    jge _L_1884276
_L_1884277:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884276:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884278
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884278:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884279"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884279:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884281
    cmp  $0,%eax
    jge _L_1884280
_L_1884281:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884280:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884282"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884282":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_1884284
    .align 8,0x90
_L_1884283 :
    .int 12
    .ascii "fx="
_L_1884284:
    movl $_L_1884283, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884285
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884285:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884286"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884286:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884288
    cmp  $0,%eax
    jge _L_1884287
_L_1884288:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884287:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884289
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884289:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884290"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884290:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884292
    cmp  $0,%eax
    jge _L_1884291
_L_1884292:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884291:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884293"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884293":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_1884295
    .align 8,0x90
_L_1884294 :
    .int 28
    .ascii "fxzero?"
_L_1884295:
    movl $_L_1884294, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884296
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884296:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884297"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884297:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884299
    cmp  $0,%eax
    jge _L_1884298
_L_1884299:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884298:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884300
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884300:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884301"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884301:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884303
    cmp  $0,%eax
    jge _L_1884302
_L_1884303:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884302:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884304"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884304":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_1884306
    .align 8,0x90
_L_1884305 :
    .int 24
    .ascii "fxsub1"
_L_1884306:
    movl $_L_1884305, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884307
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884307:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884308"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884308:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884310
    cmp  $0,%eax
    jge _L_1884309
_L_1884310:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884309:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884311
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884311:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884312"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884312:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884314
    cmp  $0,%eax
    jge _L_1884313
_L_1884314:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884313:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884315"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884315":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_1884317
    .align 8,0x90
_L_1884316 :
    .int 24
    .ascii "fxadd1"
_L_1884317:
    movl $_L_1884316, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884318
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884318:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884319"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884319:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884321
    cmp  $0,%eax
    jge _L_1884320
_L_1884321:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884320:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884322
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884322:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884323"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884323:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884325
    cmp  $0,%eax
    jge _L_1884324
_L_1884325:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884324:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884326"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884326":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_1884328
    .align 8,0x90
_L_1884327 :
    .int 28
    .ascii "fxlogor"
_L_1884328:
    movl $_L_1884327, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884329
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884329:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884330"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884330:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884332
    cmp  $0,%eax
    jge _L_1884331
_L_1884332:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884331:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884333
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884333:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884334"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884334:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884336
    cmp  $0,%eax
    jge _L_1884335
_L_1884336:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884335:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884337"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884337":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_1884339
    .align 8,0x90
_L_1884338 :
    .int 32
    .ascii "fxlogand"
_L_1884339:
    movl $_L_1884338, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884340
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884340:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884341"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884341:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884343
    cmp  $0,%eax
    jge _L_1884342
_L_1884343:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884342:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884344
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884344:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884345"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884345:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884347
    cmp  $0,%eax
    jge _L_1884346
_L_1884347:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884346:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884348"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884348":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_1884350
    .align 8,0x90
_L_1884349 :
    .int 32
    .ascii "fxlognot"
_L_1884350:
    movl $_L_1884349, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884351
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884351:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884352"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884352:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884354
    cmp  $0,%eax
    jge _L_1884353
_L_1884354:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884353:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884355
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884355:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884356"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884356:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884358
    cmp  $0,%eax
    jge _L_1884357
_L_1884358:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884357:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884359"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884359":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_1884361
    .align 8,0x90
_L_1884360 :
    .int 24
    .ascii "char=?"
_L_1884361:
    movl $_L_1884360, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884362
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884362:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884363"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884363:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884365
    cmp  $0,%eax
    jge _L_1884364
_L_1884365:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884364:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884366
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884366:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884367"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884367:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884369
    cmp  $0,%eax
    jge _L_1884368
_L_1884369:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884368:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884370"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884370":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_1884372
    .align 8,0x90
_L_1884371 :
    .int 12
    .ascii "eq?"
_L_1884372:
    movl $_L_1884371, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884373
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884373:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884374"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884374:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884376
    cmp  $0,%eax
    jge _L_1884375
_L_1884376:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884375:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884377
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884377:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884378"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884378:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884380
    cmp  $0,%eax
    jge _L_1884379
_L_1884380:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884379:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884381"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884381":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_1884383
    .align 8,0x90
_L_1884382 :
    .int 12
    .ascii "not"
_L_1884383:
    movl $_L_1884382, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884384
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884384:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884385"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884385:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884387
    cmp  $0,%eax
    jge _L_1884386
_L_1884387:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884386:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884388
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884388:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884389"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884389:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884391
    cmp  $0,%eax
    jge _L_1884390
_L_1884391:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884390:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884392"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884392":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_1884394
    .align 8,0x90
_L_1884393 :
    .int 32
    .ascii "boolean?"
_L_1884394:
    movl $_L_1884393, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884395
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884395:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884396"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884396:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884398
    cmp  $0,%eax
    jge _L_1884397
_L_1884398:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884397:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884399
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884399:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884400"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884400:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884402
    cmp  $0,%eax
    jge _L_1884401
_L_1884402:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884401:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884403"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884403":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_1884405
    .align 8,0x90
_L_1884404 :
    .int 28
    .ascii "fixnum?"
_L_1884405:
    movl $_L_1884404, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884406
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884406:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884407"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884407:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884409
    cmp  $0,%eax
    jge _L_1884408
_L_1884409:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884408:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884410
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884410:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884411"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884411:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884413
    cmp  $0,%eax
    jge _L_1884412
_L_1884413:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884412:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884414"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884414":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_1884416
    .align 8,0x90
_L_1884415 :
    .int 20
    .ascii "char?"
_L_1884416:
    movl $_L_1884415, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884417
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884417:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884418"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884418:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884420
    cmp  $0,%eax
    jge _L_1884419
_L_1884420:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884419:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884421
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884421:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884422"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884422:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884424
    cmp  $0,%eax
    jge _L_1884423
_L_1884424:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884423:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "eof-object") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "eof-object")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884425"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884425":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object"
# string literal
    jmp _L_1884427
    .align 8,0x90
_L_1884426 :
    .int 40
    .ascii "eof-object"
_L_1884427:
    movl $_L_1884426, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884428
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884428:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884429"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884429:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884431
    cmp  $0,%eax
    jge _L_1884430
_L_1884431:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884430:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884432
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884432:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884433"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884433:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884435
    cmp  $0,%eax
    jge _L_1884434
_L_1884435:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884434:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "eof-object?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "eof-object?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884436"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884436":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object?"
# string literal
    jmp _L_1884438
    .align 8,0x90
_L_1884437 :
    .int 44
    .ascii "eof-object?"
_L_1884438:
    movl $_L_1884437, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884439
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884439:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884440"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884440:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884442
    cmp  $0,%eax
    jge _L_1884441
_L_1884442:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884441:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884443
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884443:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884444"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884444:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884446
    cmp  $0,%eax
    jge _L_1884445
_L_1884446:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884445:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884447"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884447":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_1884449
    .align 8,0x90
_L_1884448 :
    .int 20
    .ascii "null?"
_L_1884449:
    movl $_L_1884448, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884450
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884450:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884451"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884451:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884453
    cmp  $0,%eax
    jge _L_1884452
_L_1884453:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884452:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))) (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884454
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884454:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884455"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884455:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884457
    cmp  $0,%eax
    jge _L_1884456
_L_1884457:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884456:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884458"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884458":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_1884460
    .align 8,0x90
_L_1884459 :
    .int 48
    .ascii "char->fixnum"
_L_1884460:
    movl $_L_1884459, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884461
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884461:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884462"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884462:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884464
    cmp  $0,%eax
    jge _L_1884463
_L_1884464:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884463:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))) (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (vector-set! f310902 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0)))
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884465
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884465:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884466"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884466:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884468
    cmp  $0,%eax
    jge _L_1884467
_L_1884468:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884467:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f310902 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f310902 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f310902 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884469"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884469":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_1884471
    .align 8,0x90
_L_1884470 :
    .int 48
    .ascii "fixnum->char"
_L_1884471:
    movl $_L_1884470, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f310902 0)
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884472
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884472:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884473"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884473:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884475
    cmp  $0,%eax
    jge _L_1884474
_L_1884475:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884474:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f310902) (let () (vector-ref f310902 0))))
# emit-begin
#   expr=(begin (closure () (f310902) (let () (vector-ref f310902 0))))
#   env=((f310902 . 0))
# emit-expr (closure () (f310902) (let () (vector-ref f310902 0)))
# emit-closure
# si = -4
# env = ((f310902 . 0))
# expr = (closure () (f310902) (let () (vector-ref f310902 0)))
    movl $_L_1884476, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310902 . 0))
# var=f310902
    movl 0(%esp), %eax  # stack load f310902
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310902
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884477            # jump around closure body
_L_1884476:
# check argument count
    cmp $0,%eax
    je _L_1884478
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884478:
# emit-tail-expr
# si=-8
# env=((f310902 . 4) (f310902 . 0))
# expr=(let () (vector-ref f310902 0))
# emit-tail-let
#  si   = -8
#  env  = ((f310902 . 4) (f310902 . 0))
#  bindings = ()
#  body = (vector-ref f310902 0)
# emit-tail-expr
# si=-8
# env=((f310902 . 4) (f310902 . 0))
# expr=(vector-ref f310902 0)
# tail primcall
# emit-expr f310902
# emit-variable-ref
# env=((f310902 . 4) (f310902 . 0))
# var=f310902
    movl 2(%edi), %eax  # frame load f310902
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884479
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884479:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884480"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884480:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884482
    cmp  $0,%eax
    jge _L_1884481
_L_1884482:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884481:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f310902 0)
    ret
    .align 4,0x90
_L_1884477:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310902 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_1884483, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884484            # jump around closure body
_L_1884483:
# check argument count
    cmp $0,%eax
    je _L_1884485
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884485:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884486"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884486":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1884488
    .align 8,0x90
_L_1884487 :
    .int 28
    .ascii "funcall"
_L_1884488:
    movl $_L_1884487, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_1884490
    .align 8,0x90
_L_1884489 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_1884490:
    movl $_L_1884489, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884484:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_1884491, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884492            # jump around closure body
_L_1884491:
# check argument count
    cmp $0,%eax
    je _L_1884493
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884493:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884494"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884494":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1884496
    .align 8,0x90
_L_1884495 :
    .int 28
    .ascii "funcall"
_L_1884496:
    movl $_L_1884495, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_1884498
    .align 8,0x90
_L_1884497 :
    .int 80
    .ascii "wrong number of args"
_L_1884498:
    movl $_L_1884497, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884492:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_1884499, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884500            # jump around closure body
_L_1884499:
# check argument count
    cmp $0,%eax
    je _L_1884501
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884501:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884502"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884502":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1884504
    .align 8,0x90
_L_1884503 :
    .int 28
    .ascii "funcall"
_L_1884504:
    movl $_L_1884503, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_1884506
    .align 8,0x90
_L_1884505 :
    .int 48
    .ascii "too few args"
_L_1884506:
    movl $_L_1884505, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884500:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f310903) (error (list-ref (primitives) f310903) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f310903) (error (list-ref (primitives) f310903) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f310903) (let ((f310903 f310903)) (error (list-ref (primitives) f310903) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f310903) () (let ((f310903 f310903)) (error (list-ref (primitives) f310903) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f310903) () (let ((f310903 f310903)) (error (list-ref (primitives) f310903) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f310903) () (let ((f310903 f310903)) (error (list-ref (primitives) f310903) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f310903) () (let ((f310903 f310903)) (error (list-ref (primitives) f310903) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f310903) () (let ((f310903 f310903)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310903) "arg must be a fixnum")))
# emit-expr (closure (f310903) () (let ((f310903 f310903)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310903) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310903) () (let ((f310903 f310903)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310903) "arg must be a fixnum")))
    movl $_L_1884507, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884508            # jump around closure body
_L_1884507:
# check argument count
    cmp $4,%eax
    je _L_1884509
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884509:
# emit-tail-expr
# si=-12
# env=((f310903 . -8))
# expr=(let ((f310903 f310903)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310903) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f310903 . -8))
#  bindings = ((f310903 f310903))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310903) "arg must be a fixnum")
# emit-expr f310903
# emit-variable-ref
# env=((f310903 . -8))
# var=f310903
    movl -8(%esp), %eax  # stack load f310903
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310903 . -12) (f310903 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310903) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310903 . -12) (f310903 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310903) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310903)
# funcall
#    si   =-20
#    env  = ((f310903 . -12) (f310903 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310903)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884510"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884510":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310903 . -12) (f310903 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884511"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884511":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310903
# emit-variable-ref
# env=((f310903 . -12) (f310903 . -8))
# var=f310903
    movl -12(%esp), %eax  # stack load f310903
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310903
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310903)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_1884513
    .align 8,0x90
_L_1884512 :
    .int 80
    .ascii "arg must be a fixnum"
_L_1884513:
    movl $_L_1884512, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884508:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f310904) (error (list-ref (primitives) f310904) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f310904) (error (list-ref (primitives) f310904) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f310904) (let ((f310904 f310904)) (error (list-ref (primitives) f310904) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f310904) () (let ((f310904 f310904)) (error (list-ref (primitives) f310904) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f310904) () (let ((f310904 f310904)) (error (list-ref (primitives) f310904) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f310904) () (let ((f310904 f310904)) (error (list-ref (primitives) f310904) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f310904) () (let ((f310904 f310904)) (error (list-ref (primitives) f310904) "arg must be a string")))
# == external-symbols  ==>
# (closure (f310904) () (let ((f310904 f310904)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310904) "arg must be a string")))
# emit-expr (closure (f310904) () (let ((f310904 f310904)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310904) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310904) () (let ((f310904 f310904)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310904) "arg must be a string")))
    movl $_L_1884514, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884515            # jump around closure body
_L_1884514:
# check argument count
    cmp $4,%eax
    je _L_1884516
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884516:
# emit-tail-expr
# si=-12
# env=((f310904 . -8))
# expr=(let ((f310904 f310904)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310904) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f310904 . -8))
#  bindings = ((f310904 f310904))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310904) "arg must be a string")
# emit-expr f310904
# emit-variable-ref
# env=((f310904 . -8))
# var=f310904
    movl -8(%esp), %eax  # stack load f310904
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310904 . -12) (f310904 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310904) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310904 . -12) (f310904 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310904) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310904)
# funcall
#    si   =-20
#    env  = ((f310904 . -12) (f310904 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310904)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884517"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884517":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310904 . -12) (f310904 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884518"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884518":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310904
# emit-variable-ref
# env=((f310904 . -12) (f310904 . -8))
# var=f310904
    movl -12(%esp), %eax  # stack load f310904
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310904
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310904)
# emit-expr "arg must be a string"
# string literal
    jmp _L_1884520
    .align 8,0x90
_L_1884519 :
    .int 80
    .ascii "arg must be a string"
_L_1884520:
    movl $_L_1884519, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884515:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f310905) (error (list-ref (primitives) f310905) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f310905) (error (list-ref (primitives) f310905) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f310905) (let ((f310905 f310905)) (error (list-ref (primitives) f310905) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f310905) () (let ((f310905 f310905)) (error (list-ref (primitives) f310905) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f310905) () (let ((f310905 f310905)) (error (list-ref (primitives) f310905) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f310905) () (let ((f310905 f310905)) (error (list-ref (primitives) f310905) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f310905) () (let ((f310905 f310905)) (error (list-ref (primitives) f310905) "arg must be a character")))
# == external-symbols  ==>
# (closure (f310905) () (let ((f310905 f310905)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310905) "arg must be a character")))
# emit-expr (closure (f310905) () (let ((f310905 f310905)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310905) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310905) () (let ((f310905 f310905)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310905) "arg must be a character")))
    movl $_L_1884521, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884522            # jump around closure body
_L_1884521:
# check argument count
    cmp $4,%eax
    je _L_1884523
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884523:
# emit-tail-expr
# si=-12
# env=((f310905 . -8))
# expr=(let ((f310905 f310905)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310905) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f310905 . -8))
#  bindings = ((f310905 f310905))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310905) "arg must be a character")
# emit-expr f310905
# emit-variable-ref
# env=((f310905 . -8))
# var=f310905
    movl -8(%esp), %eax  # stack load f310905
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310905 . -12) (f310905 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310905) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310905 . -12) (f310905 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310905) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310905)
# funcall
#    si   =-20
#    env  = ((f310905 . -12) (f310905 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310905)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884524"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884524":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310905 . -12) (f310905 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884525"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884525":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310905
# emit-variable-ref
# env=((f310905 . -12) (f310905 . -8))
# var=f310905
    movl -12(%esp), %eax  # stack load f310905
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310905
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310905)
# emit-expr "arg must be a character"
# string literal
    jmp _L_1884527
    .align 8,0x90
_L_1884526 :
    .int 92
    .ascii "arg must be a character"
_L_1884527:
    movl $_L_1884526, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884522:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f310906) (error (list-ref (primitives) f310906) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f310906) (error (list-ref (primitives) f310906) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f310906) (let ((f310906 f310906)) (error (list-ref (primitives) f310906) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f310906) () (let ((f310906 f310906)) (error (list-ref (primitives) f310906) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f310906) () (let ((f310906 f310906)) (error (list-ref (primitives) f310906) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f310906) () (let ((f310906 f310906)) (error (list-ref (primitives) f310906) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f310906) () (let ((f310906 f310906)) (error (list-ref (primitives) f310906) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f310906) () (let ((f310906 f310906)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310906) "arg must be a pair")))
# emit-expr (closure (f310906) () (let ((f310906 f310906)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310906) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310906) () (let ((f310906 f310906)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310906) "arg must be a pair")))
    movl $_L_1884528, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884529            # jump around closure body
_L_1884528:
# check argument count
    cmp $4,%eax
    je _L_1884530
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884530:
# emit-tail-expr
# si=-12
# env=((f310906 . -8))
# expr=(let ((f310906 f310906)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310906) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f310906 . -8))
#  bindings = ((f310906 f310906))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310906) "arg must be a pair")
# emit-expr f310906
# emit-variable-ref
# env=((f310906 . -8))
# var=f310906
    movl -8(%esp), %eax  # stack load f310906
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310906 . -12) (f310906 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310906) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310906 . -12) (f310906 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310906) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310906)
# funcall
#    si   =-20
#    env  = ((f310906 . -12) (f310906 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310906)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884531"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884531":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310906 . -12) (f310906 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884532"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884532":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310906
# emit-variable-ref
# env=((f310906 . -12) (f310906 . -8))
# var=f310906
    movl -12(%esp), %eax  # stack load f310906
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310906
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310906)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_1884534
    .align 8,0x90
_L_1884533 :
    .int 72
    .ascii "arg must be a pair"
_L_1884534:
    movl $_L_1884533, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884529:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f310907) (error (list-ref (primitives) f310907) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f310907) (error (list-ref (primitives) f310907) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f310907) (let ((f310907 f310907)) (error (list-ref (primitives) f310907) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f310907) () (let ((f310907 f310907)) (error (list-ref (primitives) f310907) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f310907) () (let ((f310907 f310907)) (error (list-ref (primitives) f310907) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f310907) () (let ((f310907 f310907)) (error (list-ref (primitives) f310907) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f310907) () (let ((f310907 f310907)) (error (list-ref (primitives) f310907) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f310907) () (let ((f310907 f310907)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310907) "arg must be a vector")))
# emit-expr (closure (f310907) () (let ((f310907 f310907)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310907) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310907) () (let ((f310907 f310907)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310907) "arg must be a vector")))
    movl $_L_1884535, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884536            # jump around closure body
_L_1884535:
# check argument count
    cmp $4,%eax
    je _L_1884537
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884537:
# emit-tail-expr
# si=-12
# env=((f310907 . -8))
# expr=(let ((f310907 f310907)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310907) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f310907 . -8))
#  bindings = ((f310907 f310907))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310907) "arg must be a vector")
# emit-expr f310907
# emit-variable-ref
# env=((f310907 . -8))
# var=f310907
    movl -8(%esp), %eax  # stack load f310907
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310907 . -12) (f310907 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310907) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310907 . -12) (f310907 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310907) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310907)
# funcall
#    si   =-20
#    env  = ((f310907 . -12) (f310907 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310907)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884538"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884538":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310907 . -12) (f310907 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884539"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884539":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310907
# emit-variable-ref
# env=((f310907 . -12) (f310907 . -8))
# var=f310907
    movl -12(%esp), %eax  # stack load f310907
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310907
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310907)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_1884541
    .align 8,0x90
_L_1884540 :
    .int 80
    .ascii "arg must be a vector"
_L_1884541:
    movl $_L_1884540, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884536:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f310908) (error (list-ref (primitives) f310908) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f310908) (error (list-ref (primitives) f310908) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f310908) (let ((f310908 f310908)) (error (list-ref (primitives) f310908) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f310908) () (let ((f310908 f310908)) (error (list-ref (primitives) f310908) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f310908) () (let ((f310908 f310908)) (error (list-ref (primitives) f310908) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f310908) () (let ((f310908 f310908)) (error (list-ref (primitives) f310908) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f310908) () (let ((f310908 f310908)) (error (list-ref (primitives) f310908) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f310908) () (let ((f310908 f310908)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310908) "length must be a fixnum >= 0")))
# emit-expr (closure (f310908) () (let ((f310908 f310908)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310908) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310908) () (let ((f310908 f310908)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310908) "length must be a fixnum >= 0")))
    movl $_L_1884542, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884543            # jump around closure body
_L_1884542:
# check argument count
    cmp $4,%eax
    je _L_1884544
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884544:
# emit-tail-expr
# si=-12
# env=((f310908 . -8))
# expr=(let ((f310908 f310908)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310908) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f310908 . -8))
#  bindings = ((f310908 f310908))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310908) "length must be a fixnum >= 0")
# emit-expr f310908
# emit-variable-ref
# env=((f310908 . -8))
# var=f310908
    movl -8(%esp), %eax  # stack load f310908
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310908 . -12) (f310908 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310908) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310908 . -12) (f310908 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310908) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310908)
# funcall
#    si   =-20
#    env  = ((f310908 . -12) (f310908 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310908)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884545"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884545":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310908 . -12) (f310908 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884546"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884546":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310908
# emit-variable-ref
# env=((f310908 . -12) (f310908 . -8))
# var=f310908
    movl -12(%esp), %eax  # stack load f310908
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310908
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310908)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_1884548
    .align 8,0x90
_L_1884547 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_1884548:
    movl $_L_1884547, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884543:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f310909) (error (list-ref (primitives) f310909) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f310909) (error (list-ref (primitives) f310909) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f310909) (let ((f310909 f310909)) (error (list-ref (primitives) f310909) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f310909) () (let ((f310909 f310909)) (error (list-ref (primitives) f310909) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f310909) () (let ((f310909 f310909)) (error (list-ref (primitives) f310909) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f310909) () (let ((f310909 f310909)) (error (list-ref (primitives) f310909) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f310909) () (let ((f310909 f310909)) (error (list-ref (primitives) f310909) "index out of bounds")))
# == external-symbols  ==>
# (closure (f310909) () (let ((f310909 f310909)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310909) "index out of bounds")))
# emit-expr (closure (f310909) () (let ((f310909 f310909)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310909) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310909) () (let ((f310909 f310909)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310909) "index out of bounds")))
    movl $_L_1884549, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884550            # jump around closure body
_L_1884549:
# check argument count
    cmp $4,%eax
    je _L_1884551
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884551:
# emit-tail-expr
# si=-12
# env=((f310909 . -8))
# expr=(let ((f310909 f310909)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310909) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f310909 . -8))
#  bindings = ((f310909 f310909))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310909) "index out of bounds")
# emit-expr f310909
# emit-variable-ref
# env=((f310909 . -8))
# var=f310909
    movl -8(%esp), %eax  # stack load f310909
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310909 . -12) (f310909 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310909) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310909 . -12) (f310909 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310909) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310909)
# funcall
#    si   =-20
#    env  = ((f310909 . -12) (f310909 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310909)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884552"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884552":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310909 . -12) (f310909 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884553"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884553":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310909
# emit-variable-ref
# env=((f310909 . -12) (f310909 . -8))
# var=f310909
    movl -12(%esp), %eax  # stack load f310909
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310909
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310909)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1884555
    .align 8,0x90
_L_1884554 :
    .int 76
    .ascii "index out of bounds"
_L_1884555:
    movl $_L_1884554, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884550:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f310910) (error (list-ref (primitives) f310910) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f310910) (error (list-ref (primitives) f310910) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f310910) (let ((f310910 f310910)) (error (list-ref (primitives) f310910) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f310910) () (let ((f310910 f310910)) (error (list-ref (primitives) f310910) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f310910) () (let ((f310910 f310910)) (error (list-ref (primitives) f310910) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f310910) () (let ((f310910 f310910)) (error (list-ref (primitives) f310910) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f310910) () (let ((f310910 f310910)) (error (list-ref (primitives) f310910) "index out of bounds")))
# == external-symbols  ==>
# (closure (f310910) () (let ((f310910 f310910)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310910) "index out of bounds")))
# emit-expr (closure (f310910) () (let ((f310910 f310910)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310910) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310910) () (let ((f310910 f310910)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310910) "index out of bounds")))
    movl $_L_1884556, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884557            # jump around closure body
_L_1884556:
# check argument count
    cmp $4,%eax
    je _L_1884558
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884558:
# emit-tail-expr
# si=-12
# env=((f310910 . -8))
# expr=(let ((f310910 f310910)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310910) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f310910 . -8))
#  bindings = ((f310910 f310910))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310910) "index out of bounds")
# emit-expr f310910
# emit-variable-ref
# env=((f310910 . -8))
# var=f310910
    movl -8(%esp), %eax  # stack load f310910
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310910 . -12) (f310910 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310910) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f310910 . -12) (f310910 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f310910) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f310910)
# funcall
#    si   =-20
#    env  = ((f310910 . -12) (f310910 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f310910)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884559"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884559":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f310910 . -12) (f310910 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884560"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884560":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f310910
# emit-variable-ref
# env=((f310910 . -12) (f310910 . -8))
# var=f310910
    movl -12(%esp), %eax  # stack load f310910
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310910
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f310910)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1884562
    .align 8,0x90
_L_1884561 :
    .int 76
    .ascii "index out of bounds"
_L_1884562:
    movl $_L_1884561, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884557:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f310911) (fxzero? f310911))
# == vectorize-letrec  ==>
# (lambda (f310911) (fxzero? f310911))
# == eliminate-set!  ==>
# (lambda (f310911) (let ((f310911 f310911)) (fxzero? f310911)))
# == close-free-variables  ==>
# (closure (f310911) () (let ((f310911 f310911)) (fxzero? f310911)))
# == eliminate-quote  ==>
# (closure (f310911) () (let ((f310911 f310911)) (fxzero? f310911)))
# == eliminate-when/unless  ==>
# (closure (f310911) () (let ((f310911 f310911)) (fxzero? f310911)))
# == eliminate-cond  ==>
# (closure (f310911) () (let ((f310911 f310911)) (fxzero? f310911)))
# == external-symbols  ==>
# (closure (f310911) () (let ((f310911 f310911)) (fxzero? f310911)))
# emit-expr (closure (f310911) () (let ((f310911 f310911)) (fxzero? f310911)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310911) () (let ((f310911 f310911)) (fxzero? f310911)))
    movl $_L_1884563, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884564            # jump around closure body
_L_1884563:
# check argument count
    cmp $4,%eax
    je _L_1884565
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884565:
# emit-tail-expr
# si=-12
# env=((f310911 . -8))
# expr=(let ((f310911 f310911)) (fxzero? f310911))
# emit-tail-let
#  si   = -12
#  env  = ((f310911 . -8))
#  bindings = ((f310911 f310911))
#  body = (fxzero? f310911)
# emit-expr f310911
# emit-variable-ref
# env=((f310911 . -8))
# var=f310911
    movl -8(%esp), %eax  # stack load f310911
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310911 . -12) (f310911 . -8))
# expr=(fxzero? f310911)
# tail primcall
# emit-expr f310911
# emit-variable-ref
# env=((f310911 . -12) (f310911 . -8))
# var=f310911
    movl -12(%esp), %eax  # stack load f310911
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884566"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884566:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f310911)
    ret
    .align 4,0x90
_L_1884564:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f310912) (fx> f310912 0))
# == vectorize-letrec  ==>
# (lambda (f310912) (fx> f310912 0))
# == eliminate-set!  ==>
# (lambda (f310912) (let ((f310912 f310912)) (fx> f310912 0)))
# == close-free-variables  ==>
# (closure (f310912) () (let ((f310912 f310912)) (fx> f310912 0)))
# == eliminate-quote  ==>
# (closure (f310912) () (let ((f310912 f310912)) (fx> f310912 0)))
# == eliminate-when/unless  ==>
# (closure (f310912) () (let ((f310912 f310912)) (fx> f310912 0)))
# == eliminate-cond  ==>
# (closure (f310912) () (let ((f310912 f310912)) (fx> f310912 0)))
# == external-symbols  ==>
# (closure (f310912) () (let ((f310912 f310912)) (fx> f310912 0)))
# emit-expr (closure (f310912) () (let ((f310912 f310912)) (fx> f310912 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310912) () (let ((f310912 f310912)) (fx> f310912 0)))
    movl $_L_1884567, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884568            # jump around closure body
_L_1884567:
# check argument count
    cmp $4,%eax
    je _L_1884569
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884569:
# emit-tail-expr
# si=-12
# env=((f310912 . -8))
# expr=(let ((f310912 f310912)) (fx> f310912 0))
# emit-tail-let
#  si   = -12
#  env  = ((f310912 . -8))
#  bindings = ((f310912 f310912))
#  body = (fx> f310912 0)
# emit-expr f310912
# emit-variable-ref
# env=((f310912 . -8))
# var=f310912
    movl -8(%esp), %eax  # stack load f310912
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310912 . -12) (f310912 . -8))
# expr=(fx> f310912 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884570"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884570:
    movl %eax, -16(%esp)
# emit-expr f310912
# emit-variable-ref
# env=((f310912 . -12) (f310912 . -8))
# var=f310912
    movl -12(%esp), %eax  # stack load f310912
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884571"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884571:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f310912 0)
    ret
    .align 4,0x90
_L_1884568:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f310913) (fx< f310913 0))
# == vectorize-letrec  ==>
# (lambda (f310913) (fx< f310913 0))
# == eliminate-set!  ==>
# (lambda (f310913) (let ((f310913 f310913)) (fx< f310913 0)))
# == close-free-variables  ==>
# (closure (f310913) () (let ((f310913 f310913)) (fx< f310913 0)))
# == eliminate-quote  ==>
# (closure (f310913) () (let ((f310913 f310913)) (fx< f310913 0)))
# == eliminate-when/unless  ==>
# (closure (f310913) () (let ((f310913 f310913)) (fx< f310913 0)))
# == eliminate-cond  ==>
# (closure (f310913) () (let ((f310913 f310913)) (fx< f310913 0)))
# == external-symbols  ==>
# (closure (f310913) () (let ((f310913 f310913)) (fx< f310913 0)))
# emit-expr (closure (f310913) () (let ((f310913 f310913)) (fx< f310913 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310913) () (let ((f310913 f310913)) (fx< f310913 0)))
    movl $_L_1884572, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884573            # jump around closure body
_L_1884572:
# check argument count
    cmp $4,%eax
    je _L_1884574
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884574:
# emit-tail-expr
# si=-12
# env=((f310913 . -8))
# expr=(let ((f310913 f310913)) (fx< f310913 0))
# emit-tail-let
#  si   = -12
#  env  = ((f310913 . -8))
#  bindings = ((f310913 f310913))
#  body = (fx< f310913 0)
# emit-expr f310913
# emit-variable-ref
# env=((f310913 . -8))
# var=f310913
    movl -8(%esp), %eax  # stack load f310913
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310913 . -12) (f310913 . -8))
# expr=(fx< f310913 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884575"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884575:
    movl %eax, -16(%esp)
# emit-expr f310913
# emit-variable-ref
# env=((f310913 . -12) (f310913 . -8))
# var=f310913
    movl -12(%esp), %eax  # stack load f310913
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884576"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884576:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f310913 0)
    ret
    .align 4,0x90
_L_1884573:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == eliminate-let*  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == uniquify-variables  ==>
# (lambda (f310914) (fxzero? (fxremainder f310914 2)))
# == vectorize-letrec  ==>
# (lambda (f310914) (fxzero? (fxremainder f310914 2)))
# == eliminate-set!  ==>
# (lambda (f310914) (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
# == close-free-variables  ==>
# (closure (f310914) () (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
# == eliminate-quote  ==>
# (closure (f310914) () (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
# == eliminate-when/unless  ==>
# (closure (f310914) () (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
# == eliminate-cond  ==>
# (closure (f310914) () (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
# == external-symbols  ==>
# (closure (f310914) () (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
# emit-expr (closure (f310914) () (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310914) () (let ((f310914 f310914)) (fxzero? (fxremainder f310914 2))))
    movl $_L_1884577, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884578            # jump around closure body
_L_1884577:
# check argument count
    cmp $4,%eax
    je _L_1884579
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884579:
# emit-tail-expr
# si=-12
# env=((f310914 . -8))
# expr=(let ((f310914 f310914)) (fxzero? (fxremainder f310914 2)))
# emit-tail-let
#  si   = -12
#  env  = ((f310914 . -8))
#  bindings = ((f310914 f310914))
#  body = (fxzero? (fxremainder f310914 2))
# emit-expr f310914
# emit-variable-ref
# env=((f310914 . -8))
# var=f310914
    movl -8(%esp), %eax  # stack load f310914
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310914 . -12) (f310914 . -8))
# expr=(fxzero? (fxremainder f310914 2))
# tail primcall
# emit-expr (fxremainder f310914 2)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884581"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884581:
    movl %eax, -16(%esp)  # denominator
# emit-expr f310914
# emit-variable-ref
# env=((f310914 . -12) (f310914 . -8))
# var=f310914
    movl -12(%esp), %eax  # stack load f310914
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884582"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884582:
    movl -16(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1884580
    not %edx
_L_1884580:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884583"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884583:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? (fxremainder f310914 2))
    ret
    .align 4,0x90
_L_1884578:
     movl %eax, mrc_even$q
# == explicit-begins  ==>
# (lambda (x) (not (even? x)))
# == eliminate-let*  ==>
# (lambda (x) (not (even? x)))
# == uniquify-variables  ==>
# (lambda (f310915) (not (even? f310915)))
# == vectorize-letrec  ==>
# (lambda (f310915) (not (even? f310915)))
# == eliminate-set!  ==>
# (lambda (f310915) (let ((f310915 f310915)) (not (even? f310915))))
# == close-free-variables  ==>
# (closure (f310915) () (let ((f310915 f310915)) (not (even? f310915))))
# == eliminate-quote  ==>
# (closure (f310915) () (let ((f310915 f310915)) (not (even? f310915))))
# == eliminate-when/unless  ==>
# (closure (f310915) () (let ((f310915 f310915)) (not (even? f310915))))
# == eliminate-cond  ==>
# (closure (f310915) () (let ((f310915 f310915)) (not (even? f310915))))
# == external-symbols  ==>
# (closure (f310915) () (let ((f310915 f310915)) (not ((primitive-ref even?) f310915))))
# emit-expr (closure (f310915) () (let ((f310915 f310915)) (not ((primitive-ref even?) f310915))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310915) () (let ((f310915 f310915)) (not ((primitive-ref even?) f310915))))
    movl $_L_1884584, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884585            # jump around closure body
_L_1884584:
# check argument count
    cmp $4,%eax
    je _L_1884586
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884586:
# emit-tail-expr
# si=-12
# env=((f310915 . -8))
# expr=(let ((f310915 f310915)) (not ((primitive-ref even?) f310915)))
# emit-tail-let
#  si   = -12
#  env  = ((f310915 . -8))
#  bindings = ((f310915 f310915))
#  body = (not ((primitive-ref even?) f310915))
# emit-expr f310915
# emit-variable-ref
# env=((f310915 . -8))
# var=f310915
    movl -8(%esp), %eax  # stack load f310915
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310915 . -12) (f310915 . -8))
# expr=(not ((primitive-ref even?) f310915))
# tail primcall
# emit-expr ((primitive-ref even?) f310915)
# funcall
#    si   =-16
#    env  = ((f310915 . -12) (f310915 . -8))
#    expr = (funcall (primitive-ref even?) f310915)
# emit-expr (primitive-ref even?)
    .extern mrc_even$q
    movl mrc_even$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884587"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884587":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f310915
# emit-variable-ref
# env=((f310915 . -12) (f310915 . -8))
# var=f310915
    movl -12(%esp), %eax  # stack load f310915
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f310915
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (not ((primitive-ref even?) f310915))
    ret
    .align 4,0x90
_L_1884585:
     movl %eax, mrc_odd$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f310917 f310916) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916)))))
# == vectorize-letrec  ==>
# (lambda (f310917 f310916) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916)))))
# == eliminate-set!  ==>
# (lambda (f310917 f310916) (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == close-free-variables  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == eliminate-quote  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == eliminate-when/unless  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == eliminate-cond  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == external-symbols  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))))
# emit-expr (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))))
    movl $_L_1884588, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884589            # jump around closure body
_L_1884588:
# check argument count
    cmp $8,%eax
    je _L_1884590
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884590:
# emit-tail-expr
# si=-16
# env=((f310916 . -12) (f310917 . -8))
# expr=(let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916)))))
# emit-tail-let
#  si   = -16
#  env  = ((f310916 . -12) (f310917 . -8))
#  bindings = ((f310917 f310917) (f310916 f310916))
#  body = (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))
# emit-expr f310917
# emit-variable-ref
# env=((f310916 . -12) (f310917 . -8))
# var=f310917
    movl -8(%esp), %eax  # stack load f310917
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -12) (f310917 . -8))
# var=f310916
    movl -12(%esp), %eax  # stack load f310916
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# expr=(if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))
# emit-expr (null? f310916)
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310916
    movl -20(%esp), %eax  # stack load f310916
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884591
# emit-tail-expr
# si=-24
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1884592
_L_1884591:
# emit-tail-expr
# si=-24
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# expr=(cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916)))
# tail primcall
# cons arg1=(f310917 (car f310916)) arg2=((primitive-ref map) f310917 (cdr f310916))
# emit-expr (f310917 (car f310916))
# funcall
#    si   =-24
#    env  = ((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
#    expr = (funcall f310917 (car f310916))
# emit-expr f310917
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310917
    movl -16(%esp), %eax  # stack load f310917
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884593"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884593":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f310916)
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310916
    movl -20(%esp), %eax  # stack load f310916
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884594
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884594:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f310916)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref map) f310917 (cdr f310916))
# funcall
#    si   =-28
#    env  = ((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
#    expr = (funcall (primitive-ref map) f310917 (cdr f310916))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884595"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884595":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f310917
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310917
    movl -16(%esp), %eax  # stack load f310917
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310917
# emit-expr (cdr f310916)
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310916
    movl -20(%esp), %eax  # stack load f310916
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884596
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884596:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)  # arg (cdr f310916)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916)))
    ret
_L_1884592:
    .align 4,0x90
_L_1884589:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f310919 f310918) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))))
# == vectorize-letrec  ==>
# (lambda (f310919 f310918) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))))
# == eliminate-set!  ==>
# (lambda (f310919 f310918) (let ((f310919 f310919) (f310918 f310918)) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918))))))
# == close-free-variables  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918))))))
# == eliminate-quote  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918))))))
# == eliminate-when/unless  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))) #f)))
# == eliminate-cond  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))) #f)))
# == external-symbols  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)))
# emit-expr (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)))
    movl $_L_1884597, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884598            # jump around closure body
_L_1884597:
# check argument count
    cmp $8,%eax
    je _L_1884599
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884599:
# emit-tail-expr
# si=-16
# env=((f310918 . -12) (f310919 . -8))
# expr=(let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f310918 . -12) (f310919 . -8))
#  bindings = ((f310919 f310919) (f310918 f310918))
#  body = (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)
# emit-expr f310919
# emit-variable-ref
# env=((f310918 . -12) (f310919 . -8))
# var=f310919
    movl -8(%esp), %eax  # stack load f310919
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -12) (f310919 . -8))
# var=f310918
    movl -12(%esp), %eax  # stack load f310918
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)
# emit-expr (not (null? f310918))
# emit-expr (null? f310918)
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310918
    movl -20(%esp), %eax  # stack load f310918
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884600
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918))))
# tail-begin (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918))))
#   env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))
# tail-begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))
#   env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# emit-expr (f310919 (car f310918))
# funcall
#    si   =-24
#    env  = ((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
#    expr = (funcall f310919 (car f310918))
# emit-expr f310919
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310919
    movl -16(%esp), %eax  # stack load f310919
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884602"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884602":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f310918)
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310918
    movl -20(%esp), %eax  # stack load f310918
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884603
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884603:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f310918)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(begin ((primitive-ref for-each) f310919 (cdr f310918)))
# tail-begin (begin ((primitive-ref for-each) f310919 (cdr f310918)))
#   env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=((primitive-ref for-each) f310919 (cdr f310918))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
#    expr = (funcall (primitive-ref for-each) f310919 (cdr f310918))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310919
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310919
    movl -16(%esp), %eax  # stack load f310919
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310919
# emit-expr (cdr f310918)
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310918
    movl -20(%esp), %eax  # stack load f310918
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884604
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884604:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f310918)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_1884601
_L_1884600:
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1884601:
    .align 4,0x90
_L_1884598:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 (quote output-port)) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# == vectorize-letrec  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 (quote output-port)) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# == eliminate-set!  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 (quote output-port)) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# == close-free-variables  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 (quote output-port)) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# == eliminate-quote  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 (string->symbol "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# == eliminate-when/unless  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 (string->symbol "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# == eliminate-cond  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 (string->symbol "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# == external-symbols  ==>
# (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# emit-expr (let ((f310921 (make-vector 6)) (f310920 1024)) (begin (vector-set! f310921 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310921 (make-vector 6)) (f310920 1024))
#  body = (begin (vector-set! f310921 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884605"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884605:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884606
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884606:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f310921 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
# emit-begin
#   expr=(begin (vector-set! f310921 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
#   env=((f310920 . -4) (f310921 . 0))
# emit-expr (vector-set! f310921 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f310921
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310921
    movl 0(%esp), %eax  # stack load f310921
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884607
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884607:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884608"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884608:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884610
    cmp  $0,%eax
    jge _L_1884609
_L_1884610:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884609:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f310920 . -4) (f310921 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884611"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884611":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1884613
    .align 8,0x90
_L_1884612 :
    .int 44
    .ascii "output-port"
_L_1884613:
    movl $_L_1884612, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
# emit-begin
#   expr=(begin (vector-set! f310921 1 "/dev/stdout") (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
#   env=((f310920 . -4) (f310921 . 0))
# emit-expr (vector-set! f310921 1 "/dev/stdout")
# emit-expr f310921
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310921
    movl 0(%esp), %eax  # stack load f310921
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884614
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884614:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884615"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884615:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884617
    cmp  $0,%eax
    jge _L_1884616
_L_1884617:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884616:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_1884619
    .align 8,0x90
_L_1884618 :
    .int 44
    .ascii "/dev/stdout"
_L_1884619:
    movl $_L_1884618, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
# emit-begin
#   expr=(begin (vector-set! f310921 2 1) (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
#   env=((f310920 . -4) (f310921 . 0))
# emit-expr (vector-set! f310921 2 1)
# emit-expr f310921
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310921
    movl 0(%esp), %eax  # stack load f310921
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884620
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884620:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884621"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884621:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884623
    cmp  $0,%eax
    jge _L_1884622
_L_1884623:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884622:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
# emit-begin
#   expr=(begin (vector-set! f310921 3 (make-string f310920)) (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
#   env=((f310920 . -4) (f310921 . 0))
# emit-expr (vector-set! f310921 3 (make-string f310920))
# emit-expr f310921
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310921
    movl 0(%esp), %eax  # stack load f310921
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884624
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884624:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884625"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884625:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884627
    cmp  $0,%eax
    jge _L_1884626
_L_1884627:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884626:
    movl %eax, -12(%esp)
# emit-expr (make-string f310920)
# make-string len=f310920
# emit-expr f310920
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310920
    movl -4(%esp), %eax  # stack load f310920
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884628"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884628:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884629
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884629:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
# emit-begin
#   expr=(begin (vector-set! f310921 4 0) (vector-set! f310921 5 f310920) f310921)
#   env=((f310920 . -4) (f310921 . 0))
# emit-expr (vector-set! f310921 4 0)
# emit-expr f310921
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310921
    movl 0(%esp), %eax  # stack load f310921
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884630
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884630:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884631"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884631:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884633
    cmp  $0,%eax
    jge _L_1884632
_L_1884633:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884632:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310921 5 f310920) f310921)
# emit-begin
#   expr=(begin (vector-set! f310921 5 f310920) f310921)
#   env=((f310920 . -4) (f310921 . 0))
# emit-expr (vector-set! f310921 5 f310920)
# emit-expr f310921
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310921
    movl 0(%esp), %eax  # stack load f310921
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884634
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884634:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884635"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884635:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884637
    cmp  $0,%eax
    jge _L_1884636
_L_1884637:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884636:
    movl %eax, -12(%esp)
# emit-expr f310920
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310920
    movl -4(%esp), %eax  # stack load f310920
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f310921)
# emit-begin
#   expr=(begin f310921)
#   env=((f310920 . -4) (f310921 . 0))
# emit-expr f310921
# emit-variable-ref
# env=((f310920 . -4) (f310921 . 0))
# var=f310921
    movl 0(%esp), %eax  # stack load f310921
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310920 . -4) (f310921 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f310922 standard-out)) (lambda () f310922))
# == vectorize-letrec  ==>
# (let ((f310922 standard-out)) (lambda () f310922))
# == eliminate-set!  ==>
# (let ((f310922 standard-out)) (lambda () (let () f310922)))
# == close-free-variables  ==>
# (let ((f310922 standard-out)) (closure () (f310922) (let () f310922)))
# == eliminate-quote  ==>
# (let ((f310922 standard-out)) (closure () (f310922) (let () f310922)))
# == eliminate-when/unless  ==>
# (let ((f310922 standard-out)) (closure () (f310922) (let () f310922)))
# == eliminate-cond  ==>
# (let ((f310922 standard-out)) (closure () (f310922) (let () f310922)))
# == external-symbols  ==>
# (let ((f310922 (primitive-ref standard-out))) (closure () (f310922) (let () f310922)))
# emit-expr (let ((f310922 (primitive-ref standard-out))) (closure () (f310922) (let () f310922)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310922 (primitive-ref standard-out)))
#  body = (closure () (f310922) (let () f310922))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f310922) (let () f310922))
# emit-closure
# si = -4
# env = ((f310922 . 0))
# expr = (closure () (f310922) (let () f310922))
    movl $_L_1884638, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310922 . 0))
# var=f310922
    movl 0(%esp), %eax  # stack load f310922
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310922
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884639            # jump around closure body
_L_1884638:
# check argument count
    cmp $0,%eax
    je _L_1884640
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884640:
# emit-tail-expr
# si=-8
# env=((f310922 . 4) (f310922 . 0))
# expr=(let () f310922)
# emit-tail-let
#  si   = -8
#  env  = ((f310922 . 4) (f310922 . 0))
#  bindings = ()
#  body = f310922
# emit-tail-expr
# si=-8
# env=((f310922 . 4) (f310922 . 0))
# expr=f310922
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310922 . 4) (f310922 . 0))
# var=f310922
    movl 2(%edi), %eax  # frame load f310922
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1884639:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == eliminate-let*  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == uniquify-variables  ==>
# (let ((f310923 standard-in)) (lambda () f310923))
# == vectorize-letrec  ==>
# (let ((f310923 standard-in)) (lambda () f310923))
# == eliminate-set!  ==>
# (let ((f310923 standard-in)) (lambda () (let () f310923)))
# == close-free-variables  ==>
# (let ((f310923 standard-in)) (closure () (f310923) (let () f310923)))
# == eliminate-quote  ==>
# (let ((f310923 standard-in)) (closure () (f310923) (let () f310923)))
# == eliminate-when/unless  ==>
# (let ((f310923 standard-in)) (closure () (f310923) (let () f310923)))
# == eliminate-cond  ==>
# (let ((f310923 standard-in)) (closure () (f310923) (let () f310923)))
# == external-symbols  ==>
# (let ((f310923 (primitive-ref standard-in))) (closure () (f310923) (let () f310923)))
# emit-expr (let ((f310923 (primitive-ref standard-in))) (closure () (f310923) (let () f310923)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310923 (primitive-ref standard-in)))
#  body = (closure () (f310923) (let () f310923))
# emit-expr (primitive-ref standard-in)
    .extern mrc_standard$min
    movl mrc_standard$min,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f310923) (let () f310923))
# emit-closure
# si = -4
# env = ((f310923 . 0))
# expr = (closure () (f310923) (let () f310923))
    movl $_L_1884641, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310923 . 0))
# var=f310923
    movl 0(%esp), %eax  # stack load f310923
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310923
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884642            # jump around closure body
_L_1884641:
# check argument count
    cmp $0,%eax
    je _L_1884643
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884643:
# emit-tail-expr
# si=-8
# env=((f310923 . 4) (f310923 . 0))
# expr=(let () f310923)
# emit-tail-let
#  si   = -8
#  env  = ((f310923 . 4) (f310923 . 0))
#  bindings = ()
#  body = f310923
# emit-tail-expr
# si=-8
# env=((f310923 . 4) (f310923 . 0))
# expr=f310923
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310923 . 4) (f310923 . 0))
# var=f310923
    movl 2(%edi), %eax  # frame load f310923
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1884642:
     movl %eax, mrc_current$minput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 0))
# == uniquify-variables  ==>
# (lambda (f310924) (vector-ref f310924 0))
# == vectorize-letrec  ==>
# (lambda (f310924) (vector-ref f310924 0))
# == eliminate-set!  ==>
# (lambda (f310924) (let ((f310924 f310924)) (vector-ref f310924 0)))
# == close-free-variables  ==>
# (closure (f310924) () (let ((f310924 f310924)) (vector-ref f310924 0)))
# == eliminate-quote  ==>
# (closure (f310924) () (let ((f310924 f310924)) (vector-ref f310924 0)))
# == eliminate-when/unless  ==>
# (closure (f310924) () (let ((f310924 f310924)) (vector-ref f310924 0)))
# == eliminate-cond  ==>
# (closure (f310924) () (let ((f310924 f310924)) (vector-ref f310924 0)))
# == external-symbols  ==>
# (closure (f310924) () (let ((f310924 f310924)) (vector-ref f310924 0)))
# emit-expr (closure (f310924) () (let ((f310924 f310924)) (vector-ref f310924 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310924) () (let ((f310924 f310924)) (vector-ref f310924 0)))
    movl $_L_1884644, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884645            # jump around closure body
_L_1884644:
# check argument count
    cmp $4,%eax
    je _L_1884646
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884646:
# emit-tail-expr
# si=-12
# env=((f310924 . -8))
# expr=(let ((f310924 f310924)) (vector-ref f310924 0))
# emit-tail-let
#  si   = -12
#  env  = ((f310924 . -8))
#  bindings = ((f310924 f310924))
#  body = (vector-ref f310924 0)
# emit-expr f310924
# emit-variable-ref
# env=((f310924 . -8))
# var=f310924
    movl -8(%esp), %eax  # stack load f310924
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310924 . -12) (f310924 . -8))
# expr=(vector-ref f310924 0)
# tail primcall
# emit-expr f310924
# emit-variable-ref
# env=((f310924 . -12) (f310924 . -8))
# var=f310924
    movl -12(%esp), %eax  # stack load f310924
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884647
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884647:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884648"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884648:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884650
    cmp  $0,%eax
    jge _L_1884649
_L_1884650:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884649:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f310924 0)
    ret
    .align 4,0x90
_L_1884645:
     movl %eax, mrc_port$mkind
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 1))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 1))
# == uniquify-variables  ==>
# (lambda (f310925) (vector-ref f310925 1))
# == vectorize-letrec  ==>
# (lambda (f310925) (vector-ref f310925 1))
# == eliminate-set!  ==>
# (lambda (f310925) (let ((f310925 f310925)) (vector-ref f310925 1)))
# == close-free-variables  ==>
# (closure (f310925) () (let ((f310925 f310925)) (vector-ref f310925 1)))
# == eliminate-quote  ==>
# (closure (f310925) () (let ((f310925 f310925)) (vector-ref f310925 1)))
# == eliminate-when/unless  ==>
# (closure (f310925) () (let ((f310925 f310925)) (vector-ref f310925 1)))
# == eliminate-cond  ==>
# (closure (f310925) () (let ((f310925 f310925)) (vector-ref f310925 1)))
# == external-symbols  ==>
# (closure (f310925) () (let ((f310925 f310925)) (vector-ref f310925 1)))
# emit-expr (closure (f310925) () (let ((f310925 f310925)) (vector-ref f310925 1)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310925) () (let ((f310925 f310925)) (vector-ref f310925 1)))
    movl $_L_1884651, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884652            # jump around closure body
_L_1884651:
# check argument count
    cmp $4,%eax
    je _L_1884653
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884653:
# emit-tail-expr
# si=-12
# env=((f310925 . -8))
# expr=(let ((f310925 f310925)) (vector-ref f310925 1))
# emit-tail-let
#  si   = -12
#  env  = ((f310925 . -8))
#  bindings = ((f310925 f310925))
#  body = (vector-ref f310925 1)
# emit-expr f310925
# emit-variable-ref
# env=((f310925 . -8))
# var=f310925
    movl -8(%esp), %eax  # stack load f310925
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310925 . -12) (f310925 . -8))
# expr=(vector-ref f310925 1)
# tail primcall
# emit-expr f310925
# emit-variable-ref
# env=((f310925 . -12) (f310925 . -8))
# var=f310925
    movl -12(%esp), %eax  # stack load f310925
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884654
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884654:
    movl %eax, -16(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884655"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884655:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884657
    cmp  $0,%eax
    jge _L_1884656
_L_1884657:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884656:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f310925 1)
    ret
    .align 4,0x90
_L_1884652:
     movl %eax, mrc_port$mpath
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f310926) (vector-ref f310926 2))
# == vectorize-letrec  ==>
# (lambda (f310926) (vector-ref f310926 2))
# == eliminate-set!  ==>
# (lambda (f310926) (let ((f310926 f310926)) (vector-ref f310926 2)))
# == close-free-variables  ==>
# (closure (f310926) () (let ((f310926 f310926)) (vector-ref f310926 2)))
# == eliminate-quote  ==>
# (closure (f310926) () (let ((f310926 f310926)) (vector-ref f310926 2)))
# == eliminate-when/unless  ==>
# (closure (f310926) () (let ((f310926 f310926)) (vector-ref f310926 2)))
# == eliminate-cond  ==>
# (closure (f310926) () (let ((f310926 f310926)) (vector-ref f310926 2)))
# == external-symbols  ==>
# (closure (f310926) () (let ((f310926 f310926)) (vector-ref f310926 2)))
# emit-expr (closure (f310926) () (let ((f310926 f310926)) (vector-ref f310926 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310926) () (let ((f310926 f310926)) (vector-ref f310926 2)))
    movl $_L_1884658, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884659            # jump around closure body
_L_1884658:
# check argument count
    cmp $4,%eax
    je _L_1884660
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884660:
# emit-tail-expr
# si=-12
# env=((f310926 . -8))
# expr=(let ((f310926 f310926)) (vector-ref f310926 2))
# emit-tail-let
#  si   = -12
#  env  = ((f310926 . -8))
#  bindings = ((f310926 f310926))
#  body = (vector-ref f310926 2)
# emit-expr f310926
# emit-variable-ref
# env=((f310926 . -8))
# var=f310926
    movl -8(%esp), %eax  # stack load f310926
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310926 . -12) (f310926 . -8))
# expr=(vector-ref f310926 2)
# tail primcall
# emit-expr f310926
# emit-variable-ref
# env=((f310926 . -12) (f310926 . -8))
# var=f310926
    movl -12(%esp), %eax  # stack load f310926
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884661
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884661:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884662"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884662:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884664
    cmp  $0,%eax
    jge _L_1884663
_L_1884664:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884663:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f310926 2)
    ret
    .align 4,0x90
_L_1884659:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f310927) (vector-ref f310927 3))
# == vectorize-letrec  ==>
# (lambda (f310927) (vector-ref f310927 3))
# == eliminate-set!  ==>
# (lambda (f310927) (let ((f310927 f310927)) (vector-ref f310927 3)))
# == close-free-variables  ==>
# (closure (f310927) () (let ((f310927 f310927)) (vector-ref f310927 3)))
# == eliminate-quote  ==>
# (closure (f310927) () (let ((f310927 f310927)) (vector-ref f310927 3)))
# == eliminate-when/unless  ==>
# (closure (f310927) () (let ((f310927 f310927)) (vector-ref f310927 3)))
# == eliminate-cond  ==>
# (closure (f310927) () (let ((f310927 f310927)) (vector-ref f310927 3)))
# == external-symbols  ==>
# (closure (f310927) () (let ((f310927 f310927)) (vector-ref f310927 3)))
# emit-expr (closure (f310927) () (let ((f310927 f310927)) (vector-ref f310927 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310927) () (let ((f310927 f310927)) (vector-ref f310927 3)))
    movl $_L_1884665, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884666            # jump around closure body
_L_1884665:
# check argument count
    cmp $4,%eax
    je _L_1884667
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884667:
# emit-tail-expr
# si=-12
# env=((f310927 . -8))
# expr=(let ((f310927 f310927)) (vector-ref f310927 3))
# emit-tail-let
#  si   = -12
#  env  = ((f310927 . -8))
#  bindings = ((f310927 f310927))
#  body = (vector-ref f310927 3)
# emit-expr f310927
# emit-variable-ref
# env=((f310927 . -8))
# var=f310927
    movl -8(%esp), %eax  # stack load f310927
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310927 . -12) (f310927 . -8))
# expr=(vector-ref f310927 3)
# tail primcall
# emit-expr f310927
# emit-variable-ref
# env=((f310927 . -12) (f310927 . -8))
# var=f310927
    movl -12(%esp), %eax  # stack load f310927
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884668
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884668:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884669"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884669:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884671
    cmp  $0,%eax
    jge _L_1884670
_L_1884671:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884670:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f310927 3)
    ret
    .align 4,0x90
_L_1884666:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f310928) (vector-ref f310928 4))
# == vectorize-letrec  ==>
# (lambda (f310928) (vector-ref f310928 4))
# == eliminate-set!  ==>
# (lambda (f310928) (let ((f310928 f310928)) (vector-ref f310928 4)))
# == close-free-variables  ==>
# (closure (f310928) () (let ((f310928 f310928)) (vector-ref f310928 4)))
# == eliminate-quote  ==>
# (closure (f310928) () (let ((f310928 f310928)) (vector-ref f310928 4)))
# == eliminate-when/unless  ==>
# (closure (f310928) () (let ((f310928 f310928)) (vector-ref f310928 4)))
# == eliminate-cond  ==>
# (closure (f310928) () (let ((f310928 f310928)) (vector-ref f310928 4)))
# == external-symbols  ==>
# (closure (f310928) () (let ((f310928 f310928)) (vector-ref f310928 4)))
# emit-expr (closure (f310928) () (let ((f310928 f310928)) (vector-ref f310928 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310928) () (let ((f310928 f310928)) (vector-ref f310928 4)))
    movl $_L_1884672, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884673            # jump around closure body
_L_1884672:
# check argument count
    cmp $4,%eax
    je _L_1884674
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884674:
# emit-tail-expr
# si=-12
# env=((f310928 . -8))
# expr=(let ((f310928 f310928)) (vector-ref f310928 4))
# emit-tail-let
#  si   = -12
#  env  = ((f310928 . -8))
#  bindings = ((f310928 f310928))
#  body = (vector-ref f310928 4)
# emit-expr f310928
# emit-variable-ref
# env=((f310928 . -8))
# var=f310928
    movl -8(%esp), %eax  # stack load f310928
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310928 . -12) (f310928 . -8))
# expr=(vector-ref f310928 4)
# tail primcall
# emit-expr f310928
# emit-variable-ref
# env=((f310928 . -12) (f310928 . -8))
# var=f310928
    movl -12(%esp), %eax  # stack load f310928
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884675
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884675:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884676"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884676:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884678
    cmp  $0,%eax
    jge _L_1884677
_L_1884678:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884677:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f310928 4)
    ret
    .align 4,0x90
_L_1884673:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f310929) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4))))
# == vectorize-letrec  ==>
# (lambda (f310929) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4))))
# == eliminate-set!  ==>
# (lambda (f310929) (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
# == close-free-variables  ==>
# (closure (f310929) () (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
# == eliminate-quote  ==>
# (closure (f310929) () (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
# == eliminate-when/unless  ==>
# (closure (f310929) () (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
# == eliminate-cond  ==>
# (closure (f310929) () (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
# == external-symbols  ==>
# (closure (f310929) () (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
# emit-expr (closure (f310929) () (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310929) () (let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))))
    movl $_L_1884679, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884680            # jump around closure body
_L_1884679:
# check argument count
    cmp $4,%eax
    je _L_1884681
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884681:
# emit-tail-expr
# si=-12
# env=((f310929 . -8))
# expr=(let ((f310929 f310929)) (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f310929 . -8))
#  bindings = ((f310929 f310929))
#  body = (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))
# emit-expr f310929
# emit-variable-ref
# env=((f310929 . -8))
# var=f310929
    movl -8(%esp), %eax  # stack load f310929
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310929 . -12) (f310929 . -8))
# expr=(vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))
# tail primcall
# emit-expr f310929
# emit-variable-ref
# env=((f310929 . -12) (f310929 . -8))
# var=f310929
    movl -12(%esp), %eax  # stack load f310929
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884682
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884682:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884683"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884683:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884685
    cmp  $0,%eax
    jge _L_1884684
_L_1884685:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884684:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f310929 4))
# emit-expr (vector-ref f310929 4)
# emit-expr f310929
# emit-variable-ref
# env=((f310929 . -12) (f310929 . -8))
# var=f310929
    movl -12(%esp), %eax  # stack load f310929
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884686
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884686:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884687"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884687:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884689
    cmp  $0,%eax
    jge _L_1884688
_L_1884689:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884688:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884690"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884690:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f310929 4 (fxadd1 (vector-ref f310929 4)))
    ret
    .align 4,0x90
_L_1884680:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f310930) (vector-set! f310930 4 0))
# == vectorize-letrec  ==>
# (lambda (f310930) (vector-set! f310930 4 0))
# == eliminate-set!  ==>
# (lambda (f310930) (let ((f310930 f310930)) (vector-set! f310930 4 0)))
# == close-free-variables  ==>
# (closure (f310930) () (let ((f310930 f310930)) (vector-set! f310930 4 0)))
# == eliminate-quote  ==>
# (closure (f310930) () (let ((f310930 f310930)) (vector-set! f310930 4 0)))
# == eliminate-when/unless  ==>
# (closure (f310930) () (let ((f310930 f310930)) (vector-set! f310930 4 0)))
# == eliminate-cond  ==>
# (closure (f310930) () (let ((f310930 f310930)) (vector-set! f310930 4 0)))
# == external-symbols  ==>
# (closure (f310930) () (let ((f310930 f310930)) (vector-set! f310930 4 0)))
# emit-expr (closure (f310930) () (let ((f310930 f310930)) (vector-set! f310930 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310930) () (let ((f310930 f310930)) (vector-set! f310930 4 0)))
    movl $_L_1884691, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884692            # jump around closure body
_L_1884691:
# check argument count
    cmp $4,%eax
    je _L_1884693
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884693:
# emit-tail-expr
# si=-12
# env=((f310930 . -8))
# expr=(let ((f310930 f310930)) (vector-set! f310930 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f310930 . -8))
#  bindings = ((f310930 f310930))
#  body = (vector-set! f310930 4 0)
# emit-expr f310930
# emit-variable-ref
# env=((f310930 . -8))
# var=f310930
    movl -8(%esp), %eax  # stack load f310930
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310930 . -12) (f310930 . -8))
# expr=(vector-set! f310930 4 0)
# tail primcall
# emit-expr f310930
# emit-variable-ref
# env=((f310930 . -12) (f310930 . -8))
# var=f310930
    movl -12(%esp), %eax  # stack load f310930
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884694
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884694:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884695"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884695:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884697
    cmp  $0,%eax
    jge _L_1884696
_L_1884697:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884696:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f310930 4 0)
    ret
    .align 4,0x90
_L_1884692:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f310931) (vector-ref f310931 5))
# == vectorize-letrec  ==>
# (lambda (f310931) (vector-ref f310931 5))
# == eliminate-set!  ==>
# (lambda (f310931) (let ((f310931 f310931)) (vector-ref f310931 5)))
# == close-free-variables  ==>
# (closure (f310931) () (let ((f310931 f310931)) (vector-ref f310931 5)))
# == eliminate-quote  ==>
# (closure (f310931) () (let ((f310931 f310931)) (vector-ref f310931 5)))
# == eliminate-when/unless  ==>
# (closure (f310931) () (let ((f310931 f310931)) (vector-ref f310931 5)))
# == eliminate-cond  ==>
# (closure (f310931) () (let ((f310931 f310931)) (vector-ref f310931 5)))
# == external-symbols  ==>
# (closure (f310931) () (let ((f310931 f310931)) (vector-ref f310931 5)))
# emit-expr (closure (f310931) () (let ((f310931 f310931)) (vector-ref f310931 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310931) () (let ((f310931 f310931)) (vector-ref f310931 5)))
    movl $_L_1884698, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884699            # jump around closure body
_L_1884698:
# check argument count
    cmp $4,%eax
    je _L_1884700
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884700:
# emit-tail-expr
# si=-12
# env=((f310931 . -8))
# expr=(let ((f310931 f310931)) (vector-ref f310931 5))
# emit-tail-let
#  si   = -12
#  env  = ((f310931 . -8))
#  bindings = ((f310931 f310931))
#  body = (vector-ref f310931 5)
# emit-expr f310931
# emit-variable-ref
# env=((f310931 . -8))
# var=f310931
    movl -8(%esp), %eax  # stack load f310931
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310931 . -12) (f310931 . -8))
# expr=(vector-ref f310931 5)
# tail primcall
# emit-expr f310931
# emit-variable-ref
# env=((f310931 . -12) (f310931 . -8))
# var=f310931
    movl -12(%esp), %eax  # stack load f310931
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884701
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884701:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884702"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884702:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884704
    cmp  $0,%eax
    jge _L_1884703
_L_1884704:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884703:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f310931 5)
    ret
    .align 4,0x90
_L_1884699:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
# (lambda (f310933 . f310932) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935))))
# == vectorize-letrec  ==>
# (lambda (f310933 . f310932) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935))))
# == eliminate-set!  ==>
# (lambda (f310933 . f310932) (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == close-free-variables  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == eliminate-quote  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == eliminate-when/unless  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (if (fx= (port-ndx f310935) (port-size f310935)) (begin (flush-output-port f310935)) #f) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == eliminate-cond  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (if (fx= (port-ndx f310935) (port-size f310935)) (begin (flush-output-port f310935)) #f) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == external-symbols  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))))
# emit-expr (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))))
    movl $_L_1884705, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884706            # jump around closure body
_L_1884705:
# check argument count
    cmp $4,%eax
    jge _L_1884707
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884707:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1884709:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1884708
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1884709
_L_1884708:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f310932 . -12) (f310933 . -8))
# expr=(let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))))
# emit-tail-let
#  si   = -16
#  env  = ((f310932 . -12) (f310933 . -8))
#  bindings = ((f310933 f310933))
#  body = (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))
# emit-expr f310933
# emit-variable-ref
# env=((f310932 . -12) (f310933 . -8))
# var=f310933
    movl -8(%esp), %eax  # stack load f310933
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))
# emit-tail-let
#  si   = -20
#  env  = ((f310933 . -16) (f310932 . -12) (f310933 . -8))
#  bindings = ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
# emit-expr (if (null? f310932) ((primitive-ref current-output-port)) (car f310932))
# emit-expr (null? f310932)
# emit-expr f310932
# emit-variable-ref
# env=((f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310932
    movl -12(%esp), %eax  # stack load f310932
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884710
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884712"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884712":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1884711
_L_1884710:
# emit-expr (car f310932)
# emit-expr f310932
# emit-variable-ref
# env=((f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310932
    movl -12(%esp), %eax  # stack load f310932
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884713
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884713:
    movl -1(%eax), %eax
_L_1884711:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-expr (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935))
# emit-expr ((primitive-ref port-size) f310935)
# funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-size) f310935)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884716"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884716":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310935
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310935
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884717"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884717:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f310935)
# funcall
#    si   =-28
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-ndx) f310935)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884718"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884718":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f310935
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310935
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884719"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884719:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884714
# emit-expr (begin ((primitive-ref flush-output-port) f310935))
# emit-begin
#   expr=(begin ((primitive-ref flush-output-port) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-expr ((primitive-ref flush-output-port) f310935)
# funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f310935)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884720"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884720":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310935
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310935
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
    jmp _L_1884715
_L_1884714:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1884715:
# emit-tail-expr
# si=-24
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(begin (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-expr (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933)
# emit-expr ((primitive-ref port-buf) f310935)
# funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-buf) f310935)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884721"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884721":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310935
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310935
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1884722
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884722:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f310935)
# funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-ndx) f310935)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884723"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884723":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310935
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310935
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884724"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884724:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1884726
    cmp  $0,%eax
    jge _L_1884725
_L_1884726:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884725:
    movl %eax, -28(%esp)
# emit-expr f310933
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310933
    movl -16(%esp), %eax  # stack load f310933
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1884727"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884727:
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-24
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f310935))
# tail-begin (begin ((primitive-ref port-ndx-add1) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-tail-expr
# si=-24
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=((primitive-ref port-ndx-add1) f310935)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f310935)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310935
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310935
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1884706:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f310936 (let ((f310938 (if (null? f310936) (current-output-port) (car f310936)))) (begin (foreign-call "s_write" (port-fd f310938) (port-buf f310938) (port-ndx f310938)) (port-ndx-reset f310938))))
# == vectorize-letrec  ==>
# (lambda f310936 (let ((f310938 (if (null? f310936) (current-output-port) (car f310936)))) (begin (foreign-call "s_write" (port-fd f310938) (port-buf f310938) (port-ndx f310938)) (port-ndx-reset f310938))))
# == eliminate-set!  ==>
# (lambda f310936 (let () (let ((f310938 (if (null? f310936) (current-output-port) (car f310936)))) (begin (foreign-call "s_write" (port-fd f310938) (port-buf f310938) (port-ndx f310938)) (port-ndx-reset f310938)))))
# == close-free-variables  ==>
# (closure f310936 () (let () (let ((f310938 (if (null? f310936) (current-output-port) (car f310936)))) (begin (foreign-call "s_write" (port-fd f310938) (port-buf f310938) (port-ndx f310938)) (port-ndx-reset f310938)))))
# == eliminate-quote  ==>
# (closure f310936 () (let () (let ((f310938 (if (null? f310936) (current-output-port) (car f310936)))) (begin (foreign-call "s_write" (port-fd f310938) (port-buf f310938) (port-ndx f310938)) (port-ndx-reset f310938)))))
# == eliminate-when/unless  ==>
# (closure f310936 () (let () (let ((f310938 (if (null? f310936) (current-output-port) (car f310936)))) (begin (foreign-call "s_write" (port-fd f310938) (port-buf f310938) (port-ndx f310938)) (port-ndx-reset f310938)))))
# == eliminate-cond  ==>
# (closure f310936 () (let () (let ((f310938 (if (null? f310936) (current-output-port) (car f310936)))) (begin (foreign-call "s_write" (port-fd f310938) (port-buf f310938) (port-ndx f310938)) (port-ndx-reset f310938)))))
# == external-symbols  ==>
# (closure f310936 () (let () (let ((f310938 (if (null? f310936) ((primitive-ref current-output-port)) (car f310936)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938)))))
# emit-expr (closure f310936 () (let () (let ((f310938 (if (null? f310936) ((primitive-ref current-output-port)) (car f310936)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f310936 () (let () (let ((f310938 (if (null? f310936) ((primitive-ref current-output-port)) (car f310936)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938)))))
    movl $_L_1884728, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884729            # jump around closure body
_L_1884728:
# check argument count
    cmp $0,%eax
    jge _L_1884730
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884730:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1884732:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1884731
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1884732
_L_1884731:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f310936 . -8))
# expr=(let () (let ((f310938 (if (null? f310936) ((primitive-ref current-output-port)) (car f310936)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938))))
# emit-tail-let
#  si   = -12
#  env  = ((f310936 . -8))
#  bindings = ()
#  body = (let ((f310938 (if (null? f310936) ((primitive-ref current-output-port)) (car f310936)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938)))
# emit-tail-expr
# si=-12
# env=((f310936 . -8))
# expr=(let ((f310938 (if (null? f310936) ((primitive-ref current-output-port)) (car f310936)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938)))
# emit-tail-let
#  si   = -12
#  env  = ((f310936 . -8))
#  bindings = ((f310938 (if (null? f310936) ((primitive-ref current-output-port)) (car f310936))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938))
# emit-expr (if (null? f310936) ((primitive-ref current-output-port)) (car f310936))
# emit-expr (null? f310936)
# emit-expr f310936
# emit-variable-ref
# env=((f310936 . -8))
# var=f310936
    movl -8(%esp), %eax  # stack load f310936
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884733
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f310936 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884735"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884735":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1884734
_L_1884733:
# emit-expr (car f310936)
# emit-expr f310936
# emit-variable-ref
# env=((f310936 . -8))
# var=f310936
    movl -8(%esp), %eax  # stack load f310936
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884736
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884736:
    movl -1(%eax), %eax
_L_1884734:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310938 . -12) (f310936 . -8))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938)) ((primitive-ref port-ndx-reset) f310938))
#   env=((f310938 . -12) (f310936 . -8))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f310938) ((primitive-ref port-buf) f310938) ((primitive-ref port-ndx) f310938))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f310938)
# funcall
#    si   =-24
#    env  = ((f310938 . -12) (f310936 . -8))
#    expr = (funcall (primitive-ref port-ndx) f310938)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884737"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884737":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310938
# emit-variable-ref
# env=((f310938 . -12) (f310936 . -8))
# var=f310938
    movl -12(%esp), %eax  # stack load f310938
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310938
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f310938)
# funcall
#    si   =-28
#    env  = ((f310938 . -12) (f310936 . -8))
#    expr = (funcall (primitive-ref port-buf) f310938)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884738"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884738":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f310938
# emit-variable-ref
# env=((f310938 . -12) (f310936 . -8))
# var=f310938
    movl -12(%esp), %eax  # stack load f310938
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310938
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f310938)
# funcall
#    si   =-32
#    env  = ((f310938 . -12) (f310936 . -8))
#    expr = (funcall (primitive-ref port-fd) f310938)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884739"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884739":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f310938
# emit-variable-ref
# env=((f310938 . -12) (f310936 . -8))
# var=f310938
    movl -12(%esp), %eax  # stack load f310938
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f310938
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f310938 . -12) (f310936 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f310938))
# tail-begin (begin ((primitive-ref port-ndx-reset) f310938))
#   env=((f310938 . -12) (f310936 . -8))
# emit-tail-expr
# si=-16
# env=((f310938 . -12) (f310936 . -8))
# expr=((primitive-ref port-ndx-reset) f310938)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310938 . -12) (f310936 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f310938)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310938
# emit-variable-ref
# env=((f310938 . -12) (f310936 . -8))
# var=f310938
    movl -12(%esp), %eax  # stack load f310938
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310938
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1884729:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_1884740, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884741            # jump around closure body
_L_1884740:
# check argument count
    cmp $0,%eax
    je _L_1884742
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884742:
# emit-tail-expr
# si=-8
# env=()
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = ()
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=()
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=()
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = ()
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884743"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884743":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=()
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=()
# emit-tail-expr
# si=-8
# env=()
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1884741:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_write" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_write" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == uniquify-variables  ==>
# (lambda (f310939) (begin (unless (string? f310939) (error (quote open-output-file) "filename must be a string")) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (when (negative? f310945) (error (quote open-output-file) "open failed")) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 (quote output-port)) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949))))))
# == vectorize-letrec  ==>
# (lambda (f310939) (begin (unless (string? f310939) (error (quote open-output-file) "filename must be a string")) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (when (negative? f310945) (error (quote open-output-file) "open failed")) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 (quote output-port)) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949))))))
# == eliminate-set!  ==>
# (lambda (f310939) (let ((f310939 f310939)) (begin (unless (string? f310939) (error (quote open-output-file) "filename must be a string")) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (when (negative? f310945) (error (quote open-output-file) "open failed")) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 (quote output-port)) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
# == close-free-variables  ==>
# (closure (f310939) (output-port) (let ((f310939 f310939)) (begin (unless (string? f310939) (error (quote open-output-file) "filename must be a string")) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (when (negative? f310945) (error (quote open-output-file) "open failed")) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 (quote output-port)) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
# == eliminate-quote  ==>
# (closure (f310939) (output-port) (let ((f310939 f310939)) (begin (unless (string? f310939) (error (string->symbol "open-output-file") "filename must be a string")) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (when (negative? f310945) (error (string->symbol "open-output-file") "open failed")) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 (string->symbol "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
# == eliminate-when/unless  ==>
# (closure (f310939) (output-port) (let ((f310939 f310939)) (begin (if (not (string? f310939)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if (negative? f310945) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 (string->symbol "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
# == eliminate-cond  ==>
# (closure (f310939) (output-port) (let ((f310939 f310939)) (begin (if (not (string? f310939)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if (negative? f310945) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 (string->symbol "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
# == external-symbols  ==>
# (closure (f310939) (output-port) (let ((f310939 f310939)) (begin (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
# emit-expr (closure (f310939) (output-port) (let ((f310939 f310939)) (begin (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310939) (output-port) (let ((f310939 f310939)) (begin (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))))
    movl $_L_1884744, 0(%ebp)  # closure label
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884745            # jump around closure body
_L_1884744:
# check argument count
    cmp $4,%eax
    je _L_1884746
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884746:
# emit-tail-expr
# si=-12
# env=((f310939 . -8) (output-port . 4))
# expr=(let ((f310939 f310939)) (begin (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949))))))
# emit-tail-let
#  si   = -12
#  env  = ((f310939 . -8) (output-port . 4))
#  bindings = ((f310939 f310939))
#  body = (begin (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))
# emit-expr f310939
# emit-variable-ref
# env=((f310939 . -8) (output-port . 4))
# var=f310939
    movl -8(%esp), %eax  # stack load f310939
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))
# tail-begin (begin (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))
#   env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (if (not (string? f310939)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f)
# emit-expr (not (string? f310939))
# emit-expr (string? f310939)
# emit-expr f310939
# emit-variable-ref
# env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310939
    movl -12(%esp), %eax  # stack load f310939
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884747
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
#   env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f310939 . -12) (f310939 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884749"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884749":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-28
#    env  = ((f310939 . -12) (f310939 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884750"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884750":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_1884752
    .align 8,0x90
_L_1884751 :
    .int 64
    .ascii "open-output-file"
_L_1884752:
    movl $_L_1884751, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-output-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_1884754
    .align 8,0x90
_L_1884753 :
    .int 100
    .ascii "filename must be a string"
_L_1884754:
    movl $_L_1884753, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310939 . -12) (f310939 . -8) (output-port . 4))
    jmp _L_1884748
_L_1884747:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1884748:
# emit-tail-expr
# si=-16
# env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))
# tail-begin (begin (let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))))
#   env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-tail-expr
# si=-16
# env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(let ((f310945 (foreign-call "s_open_for_write" f310939))) (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949))))
# emit-tail-let
#  si   = -16
#  env  = ((f310939 . -12) (f310939 . -8) (output-port . 4))
#  bindings = ((f310945 (foreign-call "s_open_for_write" f310939)))
#  body = (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))
# emit-expr (foreign-call "s_open_for_write" f310939)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f310939
# emit-variable-ref
# env=((f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310939
    movl -12(%esp), %eax  # stack load f310939
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open_for_write
    call _s_open_for_write
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))
# tail-begin (begin (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))
#   env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (if ((primitive-ref negative?) f310945) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f310945)
# funcall
#    si   =-20
#    env  = ((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref negative?) f310945)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884757"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884757":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f310945
# emit-variable-ref
# env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310945
    movl -16(%esp), %eax  # stack load f310945
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f310945
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1884755
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
#   env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884758"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884758":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-32
#    env  = ((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884759"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884759":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_1884761
    .align 8,0x90
_L_1884760 :
    .int 64
    .ascii "open-output-file"
_L_1884761:
    movl $_L_1884760, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-output-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "open failed"
# string literal
    jmp _L_1884763
    .align 8,0x90
_L_1884762 :
    .int 44
    .ascii "open failed"
_L_1884763:
    movl $_L_1884762, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
    jmp _L_1884756
_L_1884755:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1884756:
# emit-tail-expr
# si=-20
# env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))
# tail-begin (begin (let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)))
#   env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-tail-expr
# si=-20
# env=((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(let ((f310949 (make-vector 6)) (f310948 1024)) (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949))
# emit-tail-let
#  si   = -20
#  env  = ((f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
#  bindings = ((f310949 (make-vector 6)) (f310948 1024))
#  body = (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884764"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884764:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884765
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884765:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
# tail-begin (begin (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
#   env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (vector-set! f310949 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f310949
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310949
    movl -20(%esp), %eax  # stack load f310949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884766
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884766:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884767"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884767:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884769
    cmp  $0,%eax
    jge _L_1884768
_L_1884769:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884768:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-36
#    env  = ((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884770"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884770":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1884772
    .align 8,0x90
_L_1884771 :
    .int 44
    .ascii "output-port"
_L_1884772:
    movl $_L_1884771, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg output-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
# tail-begin (begin (vector-set! f310949 1 f310939) (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
#   env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (vector-set! f310949 1 f310939)
# emit-expr f310949
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310949
    movl -20(%esp), %eax  # stack load f310949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884773
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884773:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884774"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884774:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884776
    cmp  $0,%eax
    jge _L_1884775
_L_1884776:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884775:
    movl %eax, -32(%esp)
# emit-expr f310939
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310939
    movl -12(%esp), %eax  # stack load f310939
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
# tail-begin (begin (vector-set! f310949 2 f310945) (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
#   env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (vector-set! f310949 2 f310945)
# emit-expr f310949
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310949
    movl -20(%esp), %eax  # stack load f310949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884777
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884777:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884778"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884778:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884780
    cmp  $0,%eax
    jge _L_1884779
_L_1884780:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884779:
    movl %eax, -32(%esp)
# emit-expr f310945
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310945
    movl -16(%esp), %eax  # stack load f310945
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
# tail-begin (begin (vector-set! f310949 3 (make-string f310948)) (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
#   env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (vector-set! f310949 3 (make-string f310948))
# emit-expr f310949
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310949
    movl -20(%esp), %eax  # stack load f310949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884781
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884781:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884782"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884782:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884784
    cmp  $0,%eax
    jge _L_1884783
_L_1884784:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884783:
    movl %eax, -32(%esp)
# emit-expr (make-string f310948)
# make-string len=f310948
# emit-expr f310948
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310948
    movl -24(%esp), %eax  # stack load f310948
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884785"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884785:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884786
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884786:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
# tail-begin (begin (vector-set! f310949 4 0) (vector-set! f310949 5 f310948) f310949)
#   env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (vector-set! f310949 4 0)
# emit-expr f310949
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310949
    movl -20(%esp), %eax  # stack load f310949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884787
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884787:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884788"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884788:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884790
    cmp  $0,%eax
    jge _L_1884789
_L_1884790:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884789:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin (vector-set! f310949 5 f310948) f310949)
# tail-begin (begin (vector-set! f310949 5 f310948) f310949)
#   env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-expr (vector-set! f310949 5 f310948)
# emit-expr f310949
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310949
    movl -20(%esp), %eax  # stack load f310949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884791
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884791:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884792"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884792:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884794
    cmp  $0,%eax
    jge _L_1884793
_L_1884794:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884793:
    movl %eax, -32(%esp)
# emit-expr f310948
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310948
    movl -24(%esp), %eax  # stack load f310948
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=(begin f310949)
# tail-begin (begin f310949)
#   env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# emit-tail-expr
# si=-28
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# expr=f310949
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310948 . -24) (f310949 . -20) (f310945 . -16) (f310939 . -12) (f310939 . -8) (output-port . 4))
# var=f310949
    movl -20(%esp), %eax  # stack load f310949
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_1884745:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == eliminate-let*  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == uniquify-variables  ==>
# (lambda (f310950) (foreign-call "s_close" (port-fd f310950)))
# == vectorize-letrec  ==>
# (lambda (f310950) (foreign-call "s_close" (port-fd f310950)))
# == eliminate-set!  ==>
# (lambda (f310950) (let ((f310950 f310950)) (foreign-call "s_close" (port-fd f310950))))
# == close-free-variables  ==>
# (closure (f310950) () (let ((f310950 f310950)) (foreign-call "s_close" (port-fd f310950))))
# == eliminate-quote  ==>
# (closure (f310950) () (let ((f310950 f310950)) (foreign-call "s_close" (port-fd f310950))))
# == eliminate-when/unless  ==>
# (closure (f310950) () (let ((f310950 f310950)) (foreign-call "s_close" (port-fd f310950))))
# == eliminate-cond  ==>
# (closure (f310950) () (let ((f310950 f310950)) (foreign-call "s_close" (port-fd f310950))))
# == external-symbols  ==>
# (closure (f310950) () (let ((f310950 f310950)) (foreign-call "s_close" ((primitive-ref port-fd) f310950))))
# emit-expr (closure (f310950) () (let ((f310950 f310950)) (foreign-call "s_close" ((primitive-ref port-fd) f310950))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310950) () (let ((f310950 f310950)) (foreign-call "s_close" ((primitive-ref port-fd) f310950))))
    movl $_L_1884795, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884796            # jump around closure body
_L_1884795:
# check argument count
    cmp $4,%eax
    je _L_1884797
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884797:
# emit-tail-expr
# si=-12
# env=((f310950 . -8))
# expr=(let ((f310950 f310950)) (foreign-call "s_close" ((primitive-ref port-fd) f310950)))
# emit-tail-let
#  si   = -12
#  env  = ((f310950 . -8))
#  bindings = ((f310950 f310950))
#  body = (foreign-call "s_close" ((primitive-ref port-fd) f310950))
# emit-expr f310950
# emit-variable-ref
# env=((f310950 . -8))
# var=f310950
    movl -8(%esp), %eax  # stack load f310950
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310950 . -12) (f310950 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f310950))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f310950)
# funcall
#    si   =-24
#    env  = ((f310950 . -12) (f310950 . -8))
#    expr = (funcall (primitive-ref port-fd) f310950)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884798"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884798":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310950
# emit-variable-ref
# env=((f310950 . -12) (f310950 . -8))
# var=f310950
    movl -12(%esp), %eax  # stack load f310950
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310950
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_1884796:
     movl %eax, mrc_close$minput$mport
# == explicit-begins  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == eliminate-let*  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == uniquify-variables  ==>
# (lambda (f310951) (begin (flush-output-port f310951) (foreign-call "s_close" (port-fd f310951))))
# == vectorize-letrec  ==>
# (lambda (f310951) (begin (flush-output-port f310951) (foreign-call "s_close" (port-fd f310951))))
# == eliminate-set!  ==>
# (lambda (f310951) (let ((f310951 f310951)) (begin (flush-output-port f310951) (foreign-call "s_close" (port-fd f310951)))))
# == close-free-variables  ==>
# (closure (f310951) () (let ((f310951 f310951)) (begin (flush-output-port f310951) (foreign-call "s_close" (port-fd f310951)))))
# == eliminate-quote  ==>
# (closure (f310951) () (let ((f310951 f310951)) (begin (flush-output-port f310951) (foreign-call "s_close" (port-fd f310951)))))
# == eliminate-when/unless  ==>
# (closure (f310951) () (let ((f310951 f310951)) (begin (flush-output-port f310951) (foreign-call "s_close" (port-fd f310951)))))
# == eliminate-cond  ==>
# (closure (f310951) () (let ((f310951 f310951)) (begin (flush-output-port f310951) (foreign-call "s_close" (port-fd f310951)))))
# == external-symbols  ==>
# (closure (f310951) () (let ((f310951 f310951)) (begin ((primitive-ref flush-output-port) f310951) (foreign-call "s_close" ((primitive-ref port-fd) f310951)))))
# emit-expr (closure (f310951) () (let ((f310951 f310951)) (begin ((primitive-ref flush-output-port) f310951) (foreign-call "s_close" ((primitive-ref port-fd) f310951)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310951) () (let ((f310951 f310951)) (begin ((primitive-ref flush-output-port) f310951) (foreign-call "s_close" ((primitive-ref port-fd) f310951)))))
    movl $_L_1884799, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884800            # jump around closure body
_L_1884799:
# check argument count
    cmp $4,%eax
    je _L_1884801
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884801:
# emit-tail-expr
# si=-12
# env=((f310951 . -8))
# expr=(let ((f310951 f310951)) (begin ((primitive-ref flush-output-port) f310951) (foreign-call "s_close" ((primitive-ref port-fd) f310951))))
# emit-tail-let
#  si   = -12
#  env  = ((f310951 . -8))
#  bindings = ((f310951 f310951))
#  body = (begin ((primitive-ref flush-output-port) f310951) (foreign-call "s_close" ((primitive-ref port-fd) f310951)))
# emit-expr f310951
# emit-variable-ref
# env=((f310951 . -8))
# var=f310951
    movl -8(%esp), %eax  # stack load f310951
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310951 . -12) (f310951 . -8))
# expr=(begin ((primitive-ref flush-output-port) f310951) (foreign-call "s_close" ((primitive-ref port-fd) f310951)))
# tail-begin (begin ((primitive-ref flush-output-port) f310951) (foreign-call "s_close" ((primitive-ref port-fd) f310951)))
#   env=((f310951 . -12) (f310951 . -8))
# emit-expr ((primitive-ref flush-output-port) f310951)
# funcall
#    si   =-16
#    env  = ((f310951 . -12) (f310951 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f310951)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884802"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884802":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f310951
# emit-variable-ref
# env=((f310951 . -12) (f310951 . -8))
# var=f310951
    movl -12(%esp), %eax  # stack load f310951
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f310951
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f310951 . -12) (f310951 . -8))
# expr=(begin (foreign-call "s_close" ((primitive-ref port-fd) f310951)))
# tail-begin (begin (foreign-call "s_close" ((primitive-ref port-fd) f310951)))
#   env=((f310951 . -12) (f310951 . -8))
# emit-tail-expr
# si=-16
# env=((f310951 . -12) (f310951 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f310951))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f310951)
# funcall
#    si   =-24
#    env  = ((f310951 . -12) (f310951 . -8))
#    expr = (funcall (primitive-ref port-fd) f310951)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884803"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884803":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310951
# emit-variable-ref
# env=((f310951 . -12) (f310951 . -8))
# var=f310951
    movl -12(%esp), %eax  # stack load f310951
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310951
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1884800:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
# (letrec ((f310959 (lambda (f311001 f311000) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000))))) (f310958 (lambda (f310999) (begin (write-char #\( f310999) (write-char #\) f310999)))) (f310957 (lambda (f310998 f310997) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997)))) (f310956 (lambda (f310994 f310993) (if (negative? f310994) (begin (write-char #\- f310993) (f310956 (fx* -1 f310994) f310993)) (map (lambda (f310996) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)) (integer->list f310994))))) (f310955 (lambda (f310990 f310989) (begin (write-char #\" f310989) (for-each (lambda (f310992) (write-char f310992 f310989)) (string->list f310990)) (write-char #\" f310989)))) (f310954 (lambda (f310986 f310985) (for-each (lambda (f310988) (write-char f310988 f310985)) (string->list f310986)))) (f310953 (lambda (f310984 f310983) (begin (write-char #\( f310983) (f310952 f310984 f310983) (write-char #\) f310983)))) (f310952 (lambda (f310982 f310981) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) (f310952 (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981)))))))) (lambda (f311007 f311006 f311005) (cond ((boolean? f311007) (f310959 f311007 f311006)) ((null? f311007) (f310958 f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) (f310957 f311007 f311006))) ((fixnum? f311007) (f310956 f311007 f311006)) ((string? f311007) (if f311005 (f310954 f311007 f311006) (f310955 f311007 f311006))) ((pair? f311007) (f310953 f311007 f311006)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (lambda (f311001 f311000) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000))))) (vector-set! f310958 0 (lambda (f310999) (begin (write-char #\( f310999) (write-char #\) f310999)))) (vector-set! f310957 0 (lambda (f310998 f310997) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997)))) (vector-set! f310956 0 (lambda (f310994 f310993) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (lambda (f310996) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)) (integer->list f310994))))) (vector-set! f310955 0 (lambda (f310990 f310989) (begin (write-char #\" f310989) (for-each (lambda (f310992) (write-char f310992 f310989)) (string->list f310990)) (write-char #\" f310989)))) (vector-set! f310954 0 (lambda (f310986 f310985) (for-each (lambda (f310988) (write-char f310988 f310985)) (string->list f310986)))) (vector-set! f310953 0 (lambda (f310984 f310983) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983)))) (vector-set! f310952 0 (lambda (f310982 f310981) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981)))))))) (lambda (f311007 f311006 f311005) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (lambda (f311001 f311000) (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (lambda (f310999) (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (lambda (f310998 f310997) (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (lambda (f310994 f310993) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (lambda (f310996) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (lambda (f310990 f310989) (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (lambda (f310992) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (lambda (f310986 f310985) (let ((f310986 f310986) (f310985 f310985)) (for-each (lambda (f310988) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (lambda (f310984 f310983) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (lambda (f310982 f310981) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (lambda (f311007 f311006 f311005) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1)))
#  body = (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884804"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884804:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884805
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884805:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884806"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884806:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884807
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884807:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884808"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884808:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884809
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884809:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884810"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884810:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884811
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884811:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884812"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884812:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884813
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884813:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884814"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884814:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884815
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884815:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884816"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884816:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884817
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884817:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884818"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884818:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1884819
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884819:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -28(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000))))))
# emit-expr f310959
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310959
    movl 0(%esp), %eax  # stack load f310959
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884820
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884820:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884821"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884821:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884823
    cmp  $0,%eax
    jge _L_1884822
_L_1884823:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884822:
    movl %eax, -36(%esp)
# emit-expr (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))
    movl $_L_1884824, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884825            # jump around closure body
_L_1884824:
# check argument count
    cmp $8,%eax
    je _L_1884826
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884826:
# emit-tail-expr
# si=-16
# env=((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000))))
# emit-tail-let
#  si   = -16
#  env  = ((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f311001 f311001) (f311000 f311000))
#  body = (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
# emit-expr f311001
# emit-variable-ref
# env=((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311001
    movl -8(%esp), %eax  # stack load f311001
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -12(%esp), %eax  # stack load f311000
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
# tail-begin (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
#   env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\# f311000)
# funcall
#    si   =-24
#    env  = ((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f311000)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884827"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884827":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -20(%esp), %eax  # stack load f311000
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f311000
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
# tail-begin (begin (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
#   env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000))
# emit-expr f311001
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311001
    movl -16(%esp), %eax  # stack load f311001
# end emit-variable-ref
    cmp $47, %al
    je _L_1884828
# emit-tail-expr
# si=-24
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\t f311000)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\t f311000)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -28(%esp)    # arg t
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -20(%esp), %eax  # stack load f311000
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f311000
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1884829
_L_1884828:
# emit-tail-expr
# si=-24
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\f f311000)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\f f311000)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -28(%esp)    # arg f
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -20(%esp), %eax  # stack load f311000
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f311000
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1884829:
     ret   # return thru stack
    .align 4,0x90
_L_1884825:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999)))))
# emit-expr f310958
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310958
    movl -4(%esp), %eax  # stack load f310958
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884830
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884830:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884831"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884831:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884833
    cmp  $0,%eax
    jge _L_1884832
_L_1884833:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884832:
    movl %eax, -36(%esp)
# emit-expr (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))
    movl $_L_1884834, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884835            # jump around closure body
_L_1884834:
# check argument count
    cmp $4,%eax
    je _L_1884836
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884836:
# emit-tail-expr
# si=-12
# env=((f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999)))
# emit-tail-let
#  si   = -12
#  env  = ((f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310999 f310999))
#  body = (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))
# emit-expr f310999
# emit-variable-ref
# env=((f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310999
    movl -8(%esp), %eax  # stack load f310999
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))
# tail-begin (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))
#   env=((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\( f310999)
# funcall
#    si   =-16
#    env  = ((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f310999)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884837"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884837":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
# emit-expr f310999
# emit-variable-ref
# env=((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310999
    movl -12(%esp), %eax  # stack load f310999
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f310999
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\) f310999))
# tail-begin (begin ((primitive-ref write-char) #\) f310999))
#   env=((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-16
# env=((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\) f310999)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f310999)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
# emit-expr f310999
# emit-variable-ref
# env=((f310999 . -12) (f310999 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310999
    movl -12(%esp), %eax  # stack load f310999
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f310999
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1884835:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997)))))
# emit-expr f310957
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310957
    movl -8(%esp), %eax  # stack load f310957
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884838
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884838:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884839"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884839:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884841
    cmp  $0,%eax
    jge _L_1884840
_L_1884841:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884840:
    movl %eax, -36(%esp)
# emit-expr (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))
    movl $_L_1884842, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884843            # jump around closure body
_L_1884842:
# check argument count
    cmp $8,%eax
    je _L_1884844
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884844:
# emit-tail-expr
# si=-16
# env=((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997)))
# emit-tail-let
#  si   = -16
#  env  = ((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310998 f310998) (f310997 f310997))
#  body = (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
# emit-expr f310998
# emit-variable-ref
# env=((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310998
    movl -8(%esp), %eax  # stack load f310998
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -12(%esp), %eax  # stack load f310997
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
# tail-begin (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
#   env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\# f310997)
# funcall
#    si   =-24
#    env  = ((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f310997)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884845"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884845":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -20(%esp), %eax  # stack load f310997
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310997
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
# tail-begin (begin ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
#   env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\\ f310997)
# funcall
#    si   =-24
#    env  = ((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\\ f310997)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884846"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884846":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -36(%esp)  # arg \
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -20(%esp), %eax  # stack load f310997
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310997
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) f310998 f310997))
# tail-begin (begin ((primitive-ref write-char) f310998 f310997))
#   env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f310998 f310997)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f310998 f310997)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310998
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310998
    movl -16(%esp), %eax  # stack load f310998
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310998
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -20(%esp), %eax  # stack load f310997
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310997
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1884843:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))))))
# emit-expr f310956
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310956
    movl -12(%esp), %eax  # stack load f310956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884847
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884847:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884848"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884848:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884850
    cmp  $0,%eax
    jge _L_1884849
_L_1884850:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884849:
    movl %eax, -36(%esp)
# emit-expr (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))
    movl $_L_1884851, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310956
    movl -12(%esp), %eax  # stack load f310956
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310956
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884852            # jump around closure body
_L_1884851:
# check argument count
    cmp $8,%eax
    je _L_1884853
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884853:
# emit-tail-expr
# si=-16
# env=((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))))
# emit-tail-let
#  si   = -16
#  env  = ((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310994 f310994) (f310993 f310993))
#  body = (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -8(%esp), %eax  # stack load f310994
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310993
# emit-variable-ref
# env=((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -12(%esp), %eax  # stack load f310993
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))
# emit-expr ((primitive-ref negative?) f310994)
# funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref negative?) f310994)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884856"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884856":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -16(%esp), %eax  # stack load f310994
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310994
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1884854
# emit-tail-expr
# si=-24
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993))
# tail-begin (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993))
#   env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\- f310993)
# funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\- f310993)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884857"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884857":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -36(%esp)  # arg -
# emit-expr f310993
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -20(%esp), %eax  # stack load f310993
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310993
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((vector-ref f310956 0) (fx* -1 f310994) f310993))
# tail-begin (begin ((vector-ref f310956 0) (fx* -1 f310994) f310993))
#   env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310956 0) (fx* -1 f310994) f310993)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310956 0) (fx* -1 f310994) f310993)
# emit-expr (vector-ref f310956 0)
# emit-expr f310956
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310956
    movl 2(%edi), %eax  # frame load f310956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884858
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884858:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884859"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884859:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884861
    cmp  $0,%eax
    jge _L_1884860
_L_1884861:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884860:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fx* -1 f310994)
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -16(%esp), %eax  # stack load f310994
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884862"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884862:
    sar $2, %eax
    movl %eax, -28(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884863"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884863:
    imul -28(%esp), %eax
    mov %eax, -28(%esp)    # arg (fx* -1 f310994)
# emit-expr f310993
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -20(%esp), %eax  # stack load f310993
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310993
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1884855
_L_1884854:
# emit-tail-expr
# si=-24
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)))
# emit-closure
# si = -28
# env = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)))
    movl $_L_1884864, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -20(%esp), %eax  # stack load f310993
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310993
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884865            # jump around closure body
_L_1884864:
# check argument count
    cmp $4,%eax
    je _L_1884866
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884866:
# emit-tail-expr
# si=-12
# env=((f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))
# emit-tail-let
#  si   = -12
#  env  = ((f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310996 f310996))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)
# emit-expr f310996
# emit-variable-ref
# env=((f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310996
    movl -8(%esp), %eax  # stack load f310996
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f310996))
# emit-expr (fx+ (char->fixnum #\0) f310996)
# emit-expr f310996
# emit-variable-ref
# env=((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310996
    movl -12(%esp), %eax  # stack load f310996
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884867"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884867:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1884868"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884868:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884869"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884869:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884870"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884870:
    shll $6, %eax
    orl $15, %eax
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f310996))
# emit-expr f310993
# emit-variable-ref
# env=((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl 2(%edi), %eax  # frame load f310993
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f310993
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884865:
    mov %eax, -28(%esp)    # arg (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f310996)) f310993)))
# emit-expr ((primitive-ref integer->list) f310994)
# funcall
#    si   =-32
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref integer->list) f310994)
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884871"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884871":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -16(%esp), %eax  # stack load f310994
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f310994
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref integer->list) f310994)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1884855:
    .align 4,0x90
_L_1884852:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989)))))
# emit-expr f310955
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310955
    movl -16(%esp), %eax  # stack load f310955
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884872
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884872:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884873"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884873:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884875
    cmp  $0,%eax
    jge _L_1884874
_L_1884875:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884874:
    movl %eax, -36(%esp)
# emit-expr (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))
    movl $_L_1884876, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884877            # jump around closure body
_L_1884876:
# check argument count
    cmp $8,%eax
    je _L_1884878
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884878:
# emit-tail-expr
# si=-16
# env=((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989)))
# emit-tail-let
#  si   = -16
#  env  = ((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310990 f310990) (f310989 f310989))
#  body = (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
# emit-expr f310990
# emit-variable-ref
# env=((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310990
    movl -8(%esp), %eax  # stack load f310990
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310989
# emit-variable-ref
# env=((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -12(%esp), %eax  # stack load f310989
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
# tail-begin (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
#   env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\" f310989)
# funcall
#    si   =-24
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f310989)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884879"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884879":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -36(%esp)  # arg "
# emit-expr f310989
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -20(%esp), %eax  # stack load f310989
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310989
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
# tail-begin (begin ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
#   env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990))
# funcall
#    si   =-24
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884880"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884880":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989)))
# emit-closure
# si = -36
# env = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989)))
    movl $_L_1884881, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -20(%esp), %eax  # stack load f310989
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310989
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884882            # jump around closure body
_L_1884881:
# check argument count
    cmp $4,%eax
    je _L_1884883
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884883:
# emit-tail-expr
# si=-12
# env=((f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))
# emit-tail-let
#  si   = -12
#  env  = ((f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310992 f310992))
#  body = ((primitive-ref write-char) f310992 f310989)
# emit-expr f310992
# emit-variable-ref
# env=((f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310992
    movl -8(%esp), %eax  # stack load f310992
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f310992 f310989)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f310992 f310989)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310992
# emit-variable-ref
# env=((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310992
    movl -12(%esp), %eax  # stack load f310992
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310992
# emit-expr f310989
# emit-variable-ref
# env=((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl 2(%edi), %eax  # frame load f310989
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f310989
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884882:
    mov %eax, -36(%esp)  # arg (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989)))
# emit-expr ((primitive-ref string->list) f310990)
# funcall
#    si   =-40
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref string->list) f310990)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884884"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884884":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f310990
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310990
    movl -16(%esp), %eax  # stack load f310990
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f310990
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -40(%esp)  # arg ((primitive-ref string->list) f310990)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\" f310989))
# tail-begin (begin ((primitive-ref write-char) #\" f310989))
#   env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\" f310989)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f310989)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)    # arg "
# emit-expr f310989
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -20(%esp), %eax  # stack load f310989
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310989
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1884877:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986)))))
# emit-expr f310954
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310954
    movl -20(%esp), %eax  # stack load f310954
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884885
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884885:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884886"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884886:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884888
    cmp  $0,%eax
    jge _L_1884887
_L_1884888:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884887:
    movl %eax, -36(%esp)
# emit-expr (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))
    movl $_L_1884889, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884890            # jump around closure body
_L_1884889:
# check argument count
    cmp $8,%eax
    je _L_1884891
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884891:
# emit-tail-expr
# si=-16
# env=((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986)))
# emit-tail-let
#  si   = -16
#  env  = ((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310986 f310986) (f310985 f310985))
#  body = ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))
# emit-expr f310986
# emit-variable-ref
# env=((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310986
    movl -8(%esp), %eax  # stack load f310986
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310985
# emit-variable-ref
# env=((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310985
    movl -12(%esp), %eax  # stack load f310985
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985)))
# emit-closure
# si = -28
# env = ((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985)))
    movl $_L_1884892, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310985
    movl -20(%esp), %eax  # stack load f310985
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310985
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884893            # jump around closure body
_L_1884892:
# check argument count
    cmp $4,%eax
    je _L_1884894
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884894:
# emit-tail-expr
# si=-12
# env=((f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))
# emit-tail-let
#  si   = -12
#  env  = ((f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310988 f310988))
#  body = ((primitive-ref write-char) f310988 f310985)
# emit-expr f310988
# emit-variable-ref
# env=((f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310988
    movl -8(%esp), %eax  # stack load f310988
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f310988 f310985)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f310988 f310985)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f310988
# emit-variable-ref
# env=((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310988
    movl -12(%esp), %eax  # stack load f310988
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310988
# emit-expr f310985
# emit-variable-ref
# env=((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310985
    movl 2(%edi), %eax  # frame load f310985
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f310985
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884893:
    mov %eax, -28(%esp)    # arg (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985)))
# emit-expr ((primitive-ref string->list) f310986)
# funcall
#    si   =-32
#    env  = ((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref string->list) f310986)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884895"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884895":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f310986
# emit-variable-ref
# env=((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310986
    movl -16(%esp), %eax  # stack load f310986
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f310986
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref string->list) f310986)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884890:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983)))))
# emit-expr f310953
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310953
    movl -24(%esp), %eax  # stack load f310953
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884896
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884896:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884897"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884897:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884899
    cmp  $0,%eax
    jge _L_1884898
_L_1884899:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884898:
    movl %eax, -36(%esp)
# emit-expr (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))
    movl $_L_1884900, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310952
    movl -28(%esp), %eax  # stack load f310952
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310952
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884901            # jump around closure body
_L_1884900:
# check argument count
    cmp $8,%eax
    je _L_1884902
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884902:
# emit-tail-expr
# si=-16
# env=((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983)))
# emit-tail-let
#  si   = -16
#  env  = ((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310984 f310984) (f310983 f310983))
#  body = (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
# emit-expr f310984
# emit-variable-ref
# env=((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310984
    movl -8(%esp), %eax  # stack load f310984
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -12(%esp), %eax  # stack load f310983
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
# tail-begin (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
#   env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\( f310983)
# funcall
#    si   =-24
#    env  = ((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f310983)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884903"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884903":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -36(%esp)  # arg (
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -20(%esp), %eax  # stack load f310983
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310983
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
# tail-begin (begin ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
#   env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((vector-ref f310952 0) f310984 f310983)
# funcall
#    si   =-24
#    env  = ((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310952 0) f310984 f310983)
# emit-expr (vector-ref f310952 0)
# emit-expr f310952
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310952
    movl 2(%edi), %eax  # frame load f310952
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884904
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884904:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884905"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884905:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884907
    cmp  $0,%eax
    jge _L_1884906
_L_1884907:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884906:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884908"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884908":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f310984
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310984
    movl -16(%esp), %eax  # stack load f310984
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310984
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -20(%esp), %eax  # stack load f310983
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310983
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\) f310983))
# tail-begin (begin ((primitive-ref write-char) #\) f310983))
#   env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\) f310983)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f310983)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -28(%esp)    # arg )
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -20(%esp), %eax  # stack load f310983
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310983
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1884901:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))
# emit-expr f310952
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310952
    movl -28(%esp), %eax  # stack load f310952
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884909
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884909:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884910"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884910:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884912
    cmp  $0,%eax
    jge _L_1884911
_L_1884912:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884911:
    movl %eax, -36(%esp)
# emit-expr (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))
    movl $_L_1884913, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310952
    movl -28(%esp), %eax  # stack load f310952
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310952
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884914            # jump around closure body
_L_1884913:
# check argument count
    cmp $8,%eax
    je _L_1884915
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884915:
# emit-tail-expr
# si=-16
# env=((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))
# emit-tail-let
#  si   = -16
#  env  = ((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310982 f310982) (f310981 f310981))
#  body = (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -8(%esp), %eax  # stack load f310982
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -12(%esp), %eax  # stack load f310981
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
# tail-begin (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write) (car f310982) f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write) (car f310982) f310981)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884916"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884916":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884917
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884917:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f310982)
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
# tail-begin (begin (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))
# emit-expr (null? (cdr f310982))
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884920
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884920:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884918
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1884919
_L_1884918:
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))
# emit-expr (pair? (cdr f310982))
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884923
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884923:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884921
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\space f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f310981)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884924"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884924":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((vector-ref f310952 0) (cdr f310982) f310981))
# tail-begin (begin ((vector-ref f310952 0) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310952 0) (cdr f310982) f310981)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310952 0) (cdr f310982) f310981)
# emit-expr (vector-ref f310952 0)
# emit-expr f310952
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310952
    movl 2(%edi), %eax  # frame load f310952
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884925
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884925:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884926"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884926:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884928
    cmp  $0,%eax
    jge _L_1884927
_L_1884928:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884927:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884929
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884929:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f310982)
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310981
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1884922
_L_1884921:
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\space f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f310981)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884930"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884930":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\. f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\. f310981)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884931"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884931":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -36(%esp)  # arg .
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\space f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f310981)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884932"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884932":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write) (cdr f310982) f310981)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write) (cdr f310982) f310981)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884933
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884933:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f310982)
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310981
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1884922:
_L_1884919:
     ret   # return thru stack
    .align 4,0x90
_L_1884914:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (begin (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -32
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_1884934, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310959
    movl 0(%esp), %eax  # stack load f310959
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310959
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310958
    movl -4(%esp), %eax  # stack load f310958
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f310958
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310957
    movl -8(%esp), %eax  # stack load f310957
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f310957
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310956
    movl -12(%esp), %eax  # stack load f310956
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f310956
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310954
    movl -20(%esp), %eax  # stack load f310954
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f310954
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310955
    movl -16(%esp), %eax  # stack load f310955
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f310955
# emit-variable-ref
# env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310953
    movl -24(%esp), %eax  # stack load f310953
# end emit-variable-ref
   movl  %eax, 28(%ebp)  # f310953
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_1884935            # jump around closure body
_L_1884934:
# check argument count
    cmp $12,%eax
    je _L_1884936
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884936:
# emit-tail-expr
# si=-20
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -20
#  env  = ((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f311007 f311007) (f311006 f311006) (f311005 f311005))
#  body = (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -8(%esp), %eax  # stack load f311007
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -12(%esp), %eax  # stack load f311006
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f311005
# emit-variable-ref
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311005
    movl -16(%esp), %eax  # stack load f311005
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884937
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310959 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310959 0) f311007 f311006)
# emit-expr (vector-ref f310959 0)
# emit-expr f310959
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310959
    movl 2(%edi), %eax  # frame load f310959
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884939
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884939:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884940"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884940:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884942
    cmp  $0,%eax
    jge _L_1884941
_L_1884942:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884941:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1884938
_L_1884937:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884943
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310958 0) f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310958 0) f311006)
# emit-expr (vector-ref f310958 0)
# emit-expr f310958
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310958
    movl 6(%edi), %eax  # frame load f310958
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884945
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884945:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884946"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884946:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884948
    cmp  $0,%eax
    jge _L_1884947
_L_1884948:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884947:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=28
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1884944
_L_1884943:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884949
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006))
# emit-expr f311005
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311005
    movl -28(%esp), %eax  # stack load f311005
# end emit-variable-ref
    cmp $47, %al
    je _L_1884951
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f311007 f311006)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1884952
_L_1884951:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310957 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310957 0) f311007 f311006)
# emit-expr (vector-ref f310957 0)
# emit-expr f310957
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310957
    movl 10(%edi), %eax  # frame load f310957
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884953
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884953:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884954"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884954:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884956
    cmp  $0,%eax
    jge _L_1884955
_L_1884956:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884955:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1884952:
    jmp _L_1884950
_L_1884949:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884957
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310956 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310956 0) f311007 f311006)
# emit-expr (vector-ref f310956 0)
# emit-expr f310956
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310956
    movl 14(%edi), %eax  # frame load f310956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884959
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884959:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884960"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884960:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884962
    cmp  $0,%eax
    jge _L_1884961
_L_1884962:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884961:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1884958
_L_1884957:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884963
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))
# emit-expr f311005
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311005
    movl -28(%esp), %eax  # stack load f311005
# end emit-variable-ref
    cmp $47, %al
    je _L_1884965
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310954 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310954 0) f311007 f311006)
# emit-expr (vector-ref f310954 0)
# emit-expr f310954
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310954
    movl 18(%edi), %eax  # frame load f310954
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884967
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884967:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884968"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884968:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884970
    cmp  $0,%eax
    jge _L_1884969
_L_1884970:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884969:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1884966
_L_1884965:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310955 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310955 0) f311007 f311006)
# emit-expr (vector-ref f310955 0)
# emit-expr f310955
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310955
    movl 22(%edi), %eax  # frame load f310955
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884971
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884971:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884972"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884972:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884974
    cmp  $0,%eax
    jge _L_1884973
_L_1884974:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884973:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1884966:
    jmp _L_1884964
_L_1884963:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884975
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310953 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310953 0) f311007 f311006)
# emit-expr (vector-ref f310953 0)
# emit-expr f310953
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310953
    movl 26(%edi), %eax  # frame load f310953
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1884977
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884977:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1884978"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884978:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1884980
    cmp  $0,%eax
    jge _L_1884979
_L_1884980:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1884979:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f311006
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1884976
_L_1884975:
# emit-tail-expr
# si=-32
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-36
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884981"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884981":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_1884983
    .align 8,0x90
_L_1884982 :
    .int 20
    .ascii "write"
_L_1884983:
    movl $_L_1884982, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg write
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -36(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_1884985
    .align 8,0x90
_L_1884984 :
    .int 92
    .ascii "unrecognized expression"
_L_1884985:
    movl $_L_1884984, %eax
    orl $6, %eax
    mov %eax, -40(%esp)    # arg unrecognized expression
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1884976:
_L_1884964:
_L_1884958:
_L_1884950:
_L_1884944:
_L_1884938:
    .align 4,0x90
_L_1884935:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
     movl %eax, mrc_base$mwrite
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == uniquify-variables  ==>
# (lambda (f311009 . f311008) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f)))
# == vectorize-letrec  ==>
# (lambda (f311009 . f311008) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f)))
# == eliminate-set!  ==>
# (lambda (f311009 . f311008) (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == close-free-variables  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == eliminate-quote  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == eliminate-when/unless  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == eliminate-cond  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == external-symbols  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))))
# emit-expr (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))))
    movl $_L_1884986, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884987            # jump around closure body
_L_1884986:
# check argument count
    cmp $4,%eax
    jge _L_1884988
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884988:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1884990:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1884989
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1884990
_L_1884989:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f311008 . -12) (f311009 . -8))
# expr=(let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f311008 . -12) (f311009 . -8))
#  bindings = ((f311009 f311009))
#  body = (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))
# emit-expr f311009
# emit-variable-ref
# env=((f311008 . -12) (f311009 . -8))
# var=f311009
    movl -8(%esp), %eax  # stack load f311009
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f311009 . -16) (f311008 . -12) (f311009 . -8))
# expr=(let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))
# emit-tail-let
#  si   = -20
#  env  = ((f311009 . -16) (f311008 . -12) (f311009 . -8))
#  bindings = ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008))))
#  body = ((primitive-ref base-write) f311009 f311011 #f)
# emit-expr (if (null? f311008) ((primitive-ref current-output-port)) (car f311008))
# emit-expr (null? f311008)
# emit-expr f311008
# emit-variable-ref
# env=((f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311008
    movl -12(%esp), %eax  # stack load f311008
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1884991
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f311009 . -16) (f311008 . -12) (f311009 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1884993"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1884993":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1884992
_L_1884991:
# emit-expr (car f311008)
# emit-expr f311008
# emit-variable-ref
# env=((f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311008
    movl -12(%esp), %eax  # stack load f311008
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1884994
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1884994:
    movl -1(%eax), %eax
_L_1884992:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
# expr=((primitive-ref base-write) f311009 f311011 #f)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
#    expr = (funcall (primitive-ref base-write) f311009 f311011 #f)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311009
# emit-variable-ref
# env=((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311009
    movl -16(%esp), %eax  # stack load f311009
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f311009
# emit-expr f311011
# emit-variable-ref
# env=((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311011
    movl -20(%esp), %eax  # stack load f311011
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f311011
# emit-expr #f
    movl $47, %eax     # immed #f
    mov %eax, -36(%esp)    # arg #f
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884987:
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == uniquify-variables  ==>
# (lambda (f311013 . f311012) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t)))
# == vectorize-letrec  ==>
# (lambda (f311013 . f311012) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t)))
# == eliminate-set!  ==>
# (lambda (f311013 . f311012) (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == close-free-variables  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == eliminate-quote  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == eliminate-when/unless  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == eliminate-cond  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == external-symbols  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))))
# emit-expr (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))))
    movl $_L_1884995, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1884996            # jump around closure body
_L_1884995:
# check argument count
    cmp $4,%eax
    jge _L_1884997
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1884997:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1884999:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1884998
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1884999
_L_1884998:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f311012 . -12) (f311013 . -8))
# expr=(let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t)))
# emit-tail-let
#  si   = -16
#  env  = ((f311012 . -12) (f311013 . -8))
#  bindings = ((f311013 f311013))
#  body = (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))
# emit-expr f311013
# emit-variable-ref
# env=((f311012 . -12) (f311013 . -8))
# var=f311013
    movl -8(%esp), %eax  # stack load f311013
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f311013 . -16) (f311012 . -12) (f311013 . -8))
# expr=(let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))
# emit-tail-let
#  si   = -20
#  env  = ((f311013 . -16) (f311012 . -12) (f311013 . -8))
#  bindings = ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012))))
#  body = ((primitive-ref base-write) f311013 f311015 #t)
# emit-expr (if (null? f311012) ((primitive-ref current-output-port)) (car f311012))
# emit-expr (null? f311012)
# emit-expr f311012
# emit-variable-ref
# env=((f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311012
    movl -12(%esp), %eax  # stack load f311012
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885000
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f311013 . -16) (f311012 . -12) (f311013 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885002"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885002":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1885001
_L_1885000:
# emit-expr (car f311012)
# emit-expr f311012
# emit-variable-ref
# env=((f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311012
    movl -12(%esp), %eax  # stack load f311012
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1885003
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885003:
    movl -1(%eax), %eax
_L_1885001:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
# expr=((primitive-ref base-write) f311013 f311015 #t)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
#    expr = (funcall (primitive-ref base-write) f311013 f311015 #t)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311013
# emit-variable-ref
# env=((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311013
    movl -16(%esp), %eax  # stack load f311013
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f311013
# emit-expr f311015
# emit-variable-ref
# env=((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311015
    movl -20(%esp), %eax  # stack load f311015
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f311015
# emit-expr #t
    movl $111, %eax     # immed #t
    mov %eax, -36(%esp)    # arg #t
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1884996:
     movl %eax, mrc_display
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f311016) (fixnum->char f311016))
# == vectorize-letrec  ==>
# (lambda (f311016) (fixnum->char f311016))
# == eliminate-set!  ==>
# (lambda (f311016) (let ((f311016 f311016)) (fixnum->char f311016)))
# == close-free-variables  ==>
# (closure (f311016) () (let ((f311016 f311016)) (fixnum->char f311016)))
# == eliminate-quote  ==>
# (closure (f311016) () (let ((f311016 f311016)) (fixnum->char f311016)))
# == eliminate-when/unless  ==>
# (closure (f311016) () (let ((f311016 f311016)) (fixnum->char f311016)))
# == eliminate-cond  ==>
# (closure (f311016) () (let ((f311016 f311016)) (fixnum->char f311016)))
# == external-symbols  ==>
# (closure (f311016) () (let ((f311016 f311016)) (fixnum->char f311016)))
# emit-expr (closure (f311016) () (let ((f311016 f311016)) (fixnum->char f311016)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311016) () (let ((f311016 f311016)) (fixnum->char f311016)))
    movl $_L_1885004, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885005            # jump around closure body
_L_1885004:
# check argument count
    cmp $4,%eax
    je _L_1885006
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885006:
# emit-tail-expr
# si=-12
# env=((f311016 . -8))
# expr=(let ((f311016 f311016)) (fixnum->char f311016))
# emit-tail-let
#  si   = -12
#  env  = ((f311016 . -8))
#  bindings = ((f311016 f311016))
#  body = (fixnum->char f311016)
# emit-expr f311016
# emit-variable-ref
# env=((f311016 . -8))
# var=f311016
    movl -8(%esp), %eax  # stack load f311016
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311016 . -12) (f311016 . -8))
# expr=(fixnum->char f311016)
# tail primcall
# emit-expr f311016
# emit-variable-ref
# env=((f311016 . -12) (f311016 . -8))
# var=f311016
    movl -12(%esp), %eax  # stack load f311016
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885007"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885007:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f311016)
    ret
    .align 4,0x90
_L_1885005:
     movl %eax, mrc_integer$m$gchar
# == explicit-begins  ==>
# (let* ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 8))) (let ((sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p)))
# == uniquify-variables  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 (quote input-port)) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# == vectorize-letrec  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 (quote input-port)) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# == eliminate-set!  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 (quote input-port)) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# == close-free-variables  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 (quote input-port)) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# == eliminate-quote  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 (string->symbol "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# == eliminate-when/unless  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 (string->symbol "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# == eliminate-cond  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 (string->symbol "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# == external-symbols  ==>
# (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# emit-expr (let ((f311017 (make-vector 8))) (let ((f311019 1024)) (begin (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f311017 (make-vector 8)))
#  body = (let ((f311019 1024)) (begin (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017))
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885008"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885008:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1885009
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885009:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f311019 1024)) (begin (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017))
# emit-let
#  si   = -4
#  env  = ((f311017 . 0))
#  bindings = ((f311019 1024))
#  body = (begin (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885010
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885010:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885011"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885011:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885013
    cmp  $0,%eax
    jge _L_1885012
_L_1885013:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885012:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-16
#    env  = ((f311019 . -4) (f311017 . 0))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885014"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885014":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_1885016
    .align 8,0x90
_L_1885015 :
    .int 40
    .ascii "input-port"
_L_1885016:
    movl $_L_1885015, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg input-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 1 "/dev/stdin") (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 1 "/dev/stdin")
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885017
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885017:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885018"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885018:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885020
    cmp  $0,%eax
    jge _L_1885019
_L_1885020:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885019:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdin"
# string literal
    jmp _L_1885022
    .align 8,0x90
_L_1885021 :
    .int 40
    .ascii "/dev/stdin"
_L_1885022:
    movl $_L_1885021, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 2 0) (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 2 0)
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885023
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885023:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885024"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885024:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885026
    cmp  $0,%eax
    jge _L_1885025
_L_1885026:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885025:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 3 (make-string f311019)) (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 3 (make-string f311019))
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885027
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885027:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885028"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885028:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885030
    cmp  $0,%eax
    jge _L_1885029
_L_1885030:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885029:
    movl %eax, -12(%esp)
# emit-expr (make-string f311019)
# make-string len=f311019
# emit-expr f311019
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311019
    movl -4(%esp), %eax  # stack load f311019
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885031"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885031:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1885032
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885032:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 4 0) (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 4 0)
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885033
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885033:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885034"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885034:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885036
    cmp  $0,%eax
    jge _L_1885035
_L_1885036:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885035:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 5 f311019) (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 5 f311019)
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885037
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885037:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885038"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885038:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885040
    cmp  $0,%eax
    jge _L_1885039
_L_1885040:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885039:
    movl %eax, -12(%esp)
# emit-expr f311019
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311019
    movl -4(%esp), %eax  # stack load f311019
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 6 #f) (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 6 #f)
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885041
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885041:
    movl %eax, -8(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885042"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885042:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885044
    cmp  $0,%eax
    jge _L_1885043
_L_1885044:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885043:
    movl %eax, -12(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f311017 7 -1) f311017)
# emit-begin
#   expr=(begin (vector-set! f311017 7 -1) f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr (vector-set! f311017 7 -1)
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885045
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885045:
    movl %eax, -8(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885046"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885046:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885048
    cmp  $0,%eax
    jge _L_1885047
_L_1885048:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885047:
    movl %eax, -12(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f311017)
# emit-begin
#   expr=(begin f311017)
#   env=((f311019 . -4) (f311017 . 0))
# emit-expr f311017
# emit-variable-ref
# env=((f311019 . -4) (f311017 . 0))
# var=f311017
    movl 0(%esp), %eax  # stack load f311017
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f311019 . -4) (f311017 . 0))
     movl %eax, mrc_standard$min
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 6))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 6))
# == uniquify-variables  ==>
# (lambda (f311020) (vector-ref f311020 6))
# == vectorize-letrec  ==>
# (lambda (f311020) (vector-ref f311020 6))
# == eliminate-set!  ==>
# (lambda (f311020) (let ((f311020 f311020)) (vector-ref f311020 6)))
# == close-free-variables  ==>
# (closure (f311020) () (let ((f311020 f311020)) (vector-ref f311020 6)))
# == eliminate-quote  ==>
# (closure (f311020) () (let ((f311020 f311020)) (vector-ref f311020 6)))
# == eliminate-when/unless  ==>
# (closure (f311020) () (let ((f311020 f311020)) (vector-ref f311020 6)))
# == eliminate-cond  ==>
# (closure (f311020) () (let ((f311020 f311020)) (vector-ref f311020 6)))
# == external-symbols  ==>
# (closure (f311020) () (let ((f311020 f311020)) (vector-ref f311020 6)))
# emit-expr (closure (f311020) () (let ((f311020 f311020)) (vector-ref f311020 6)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311020) () (let ((f311020 f311020)) (vector-ref f311020 6)))
    movl $_L_1885049, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885050            # jump around closure body
_L_1885049:
# check argument count
    cmp $4,%eax
    je _L_1885051
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885051:
# emit-tail-expr
# si=-12
# env=((f311020 . -8))
# expr=(let ((f311020 f311020)) (vector-ref f311020 6))
# emit-tail-let
#  si   = -12
#  env  = ((f311020 . -8))
#  bindings = ((f311020 f311020))
#  body = (vector-ref f311020 6)
# emit-expr f311020
# emit-variable-ref
# env=((f311020 . -8))
# var=f311020
    movl -8(%esp), %eax  # stack load f311020
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311020 . -12) (f311020 . -8))
# expr=(vector-ref f311020 6)
# tail primcall
# emit-expr f311020
# emit-variable-ref
# env=((f311020 . -12) (f311020 . -8))
# var=f311020
    movl -12(%esp), %eax  # stack load f311020
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885052
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885052:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885053"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885053:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885055
    cmp  $0,%eax
    jge _L_1885054
_L_1885055:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885054:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f311020 6)
    ret
    .align 4,0x90
_L_1885050:
     movl %eax, mrc_port$munread
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 6 #f))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 6 #f))
# == uniquify-variables  ==>
# (lambda (f311021) (vector-set! f311021 6 #f))
# == vectorize-letrec  ==>
# (lambda (f311021) (vector-set! f311021 6 #f))
# == eliminate-set!  ==>
# (lambda (f311021) (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
# == close-free-variables  ==>
# (closure (f311021) () (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
# == eliminate-quote  ==>
# (closure (f311021) () (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
# == eliminate-when/unless  ==>
# (closure (f311021) () (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
# == eliminate-cond  ==>
# (closure (f311021) () (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
# == external-symbols  ==>
# (closure (f311021) () (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
# emit-expr (closure (f311021) () (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311021) () (let ((f311021 f311021)) (vector-set! f311021 6 #f)))
    movl $_L_1885056, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885057            # jump around closure body
_L_1885056:
# check argument count
    cmp $4,%eax
    je _L_1885058
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885058:
# emit-tail-expr
# si=-12
# env=((f311021 . -8))
# expr=(let ((f311021 f311021)) (vector-set! f311021 6 #f))
# emit-tail-let
#  si   = -12
#  env  = ((f311021 . -8))
#  bindings = ((f311021 f311021))
#  body = (vector-set! f311021 6 #f)
# emit-expr f311021
# emit-variable-ref
# env=((f311021 . -8))
# var=f311021
    movl -8(%esp), %eax  # stack load f311021
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311021 . -12) (f311021 . -8))
# expr=(vector-set! f311021 6 #f)
# tail primcall
# emit-expr f311021
# emit-variable-ref
# env=((f311021 . -12) (f311021 . -8))
# var=f311021
    movl -12(%esp), %eax  # stack load f311021
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885059
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885059:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885060"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885060:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885062
    cmp  $0,%eax
    jge _L_1885061
_L_1885062:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885061:
    movl %eax, -20(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f311021 6 #f)
    ret
    .align 4,0x90
_L_1885057:
     movl %eax, mrc_port$munread$mclear
# == explicit-begins  ==>
# (lambda (p x) (vector-set! p 6 x))
# == eliminate-let*  ==>
# (lambda (p x) (vector-set! p 6 x))
# == uniquify-variables  ==>
# (lambda (f311023 f311022) (vector-set! f311023 6 f311022))
# == vectorize-letrec  ==>
# (lambda (f311023 f311022) (vector-set! f311023 6 f311022))
# == eliminate-set!  ==>
# (lambda (f311023 f311022) (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == close-free-variables  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == eliminate-quote  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == eliminate-when/unless  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == eliminate-cond  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == external-symbols  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# emit-expr (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
    movl $_L_1885063, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885064            # jump around closure body
_L_1885063:
# check argument count
    cmp $8,%eax
    je _L_1885065
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885065:
# emit-tail-expr
# si=-16
# env=((f311022 . -12) (f311023 . -8))
# expr=(let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022))
# emit-tail-let
#  si   = -16
#  env  = ((f311022 . -12) (f311023 . -8))
#  bindings = ((f311023 f311023) (f311022 f311022))
#  body = (vector-set! f311023 6 f311022)
# emit-expr f311023
# emit-variable-ref
# env=((f311022 . -12) (f311023 . -8))
# var=f311023
    movl -8(%esp), %eax  # stack load f311023
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f311022
# emit-variable-ref
# env=((f311022 . -12) (f311023 . -8))
# var=f311022
    movl -12(%esp), %eax  # stack load f311022
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f311022 . -20) (f311023 . -16) (f311022 . -12) (f311023 . -8))
# expr=(vector-set! f311023 6 f311022)
# tail primcall
# emit-expr f311023
# emit-variable-ref
# env=((f311022 . -20) (f311023 . -16) (f311022 . -12) (f311023 . -8))
# var=f311023
    movl -16(%esp), %eax  # stack load f311023
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885066
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885066:
    movl %eax, -24(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885067"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885067:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885069
    cmp  $0,%eax
    jge _L_1885068
_L_1885069:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885068:
    movl %eax, -28(%esp)
# emit-expr f311022
# emit-variable-ref
# env=((f311022 . -20) (f311023 . -16) (f311022 . -12) (f311023 . -8))
# var=f311022
    movl -20(%esp), %eax  # stack load f311022
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f311023 6 f311022)
    ret
    .align 4,0x90
_L_1885064:
     movl %eax, mrc_port$munread$mset$b
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 7))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 7))
# == uniquify-variables  ==>
# (lambda (f311024) (vector-ref f311024 7))
# == vectorize-letrec  ==>
# (lambda (f311024) (vector-ref f311024 7))
# == eliminate-set!  ==>
# (lambda (f311024) (let ((f311024 f311024)) (vector-ref f311024 7)))
# == close-free-variables  ==>
# (closure (f311024) () (let ((f311024 f311024)) (vector-ref f311024 7)))
# == eliminate-quote  ==>
# (closure (f311024) () (let ((f311024 f311024)) (vector-ref f311024 7)))
# == eliminate-when/unless  ==>
# (closure (f311024) () (let ((f311024 f311024)) (vector-ref f311024 7)))
# == eliminate-cond  ==>
# (closure (f311024) () (let ((f311024 f311024)) (vector-ref f311024 7)))
# == external-symbols  ==>
# (closure (f311024) () (let ((f311024 f311024)) (vector-ref f311024 7)))
# emit-expr (closure (f311024) () (let ((f311024 f311024)) (vector-ref f311024 7)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311024) () (let ((f311024 f311024)) (vector-ref f311024 7)))
    movl $_L_1885070, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885071            # jump around closure body
_L_1885070:
# check argument count
    cmp $4,%eax
    je _L_1885072
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885072:
# emit-tail-expr
# si=-12
# env=((f311024 . -8))
# expr=(let ((f311024 f311024)) (vector-ref f311024 7))
# emit-tail-let
#  si   = -12
#  env  = ((f311024 . -8))
#  bindings = ((f311024 f311024))
#  body = (vector-ref f311024 7)
# emit-expr f311024
# emit-variable-ref
# env=((f311024 . -8))
# var=f311024
    movl -8(%esp), %eax  # stack load f311024
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311024 . -12) (f311024 . -8))
# expr=(vector-ref f311024 7)
# tail primcall
# emit-expr f311024
# emit-variable-ref
# env=((f311024 . -12) (f311024 . -8))
# var=f311024
    movl -12(%esp), %eax  # stack load f311024
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885073
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885073:
    movl %eax, -16(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885074"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885074:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885076
    cmp  $0,%eax
    jge _L_1885075
_L_1885076:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885075:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f311024 7)
    ret
    .align 4,0x90
_L_1885071:
     movl %eax, mrc_port$mlast
# == explicit-begins  ==>
# (lambda (p i) (vector-set! p 7 i))
# == eliminate-let*  ==>
# (lambda (p i) (vector-set! p 7 i))
# == uniquify-variables  ==>
# (lambda (f311026 f311025) (vector-set! f311026 7 f311025))
# == vectorize-letrec  ==>
# (lambda (f311026 f311025) (vector-set! f311026 7 f311025))
# == eliminate-set!  ==>
# (lambda (f311026 f311025) (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == close-free-variables  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == eliminate-quote  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == eliminate-when/unless  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == eliminate-cond  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == external-symbols  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# emit-expr (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
    movl $_L_1885077, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885078            # jump around closure body
_L_1885077:
# check argument count
    cmp $8,%eax
    je _L_1885079
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885079:
# emit-tail-expr
# si=-16
# env=((f311025 . -12) (f311026 . -8))
# expr=(let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025))
# emit-tail-let
#  si   = -16
#  env  = ((f311025 . -12) (f311026 . -8))
#  bindings = ((f311026 f311026) (f311025 f311025))
#  body = (vector-set! f311026 7 f311025)
# emit-expr f311026
# emit-variable-ref
# env=((f311025 . -12) (f311026 . -8))
# var=f311026
    movl -8(%esp), %eax  # stack load f311026
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f311025
# emit-variable-ref
# env=((f311025 . -12) (f311026 . -8))
# var=f311025
    movl -12(%esp), %eax  # stack load f311025
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f311025 . -20) (f311026 . -16) (f311025 . -12) (f311026 . -8))
# expr=(vector-set! f311026 7 f311025)
# tail primcall
# emit-expr f311026
# emit-variable-ref
# env=((f311025 . -20) (f311026 . -16) (f311025 . -12) (f311026 . -8))
# var=f311026
    movl -16(%esp), %eax  # stack load f311026
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885080
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885080:
    movl %eax, -24(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885081"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885081:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885083
    cmp  $0,%eax
    jge _L_1885082
_L_1885083:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885082:
    movl %eax, -28(%esp)
# emit-expr f311025
# emit-variable-ref
# env=((f311025 . -20) (f311026 . -16) (f311025 . -12) (f311026 . -8))
# var=f311025
    movl -20(%esp), %eax  # stack load f311025
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f311026 7 f311025)
    ret
    .align 4,0x90
_L_1885078:
     movl %eax, mrc_port$mlast$mset$b
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == uniquify-variables  ==>
# (lambda (f311027) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? (port-kind f311027) (quote input-port)))))
# == vectorize-letrec  ==>
# (lambda (f311027) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? (port-kind f311027) (quote input-port)))))
# == eliminate-set!  ==>
# (lambda (f311027) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? (port-kind f311027) (quote input-port))))))
# == close-free-variables  ==>
# (closure (f311027) (and and input-port) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? (port-kind f311027) (quote input-port))))))
# == eliminate-quote  ==>
# (closure (f311027) (and and input-port) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? (port-kind f311027) (string->symbol "input-port"))))))
# == eliminate-when/unless  ==>
# (closure (f311027) (and and input-port) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? (port-kind f311027) (string->symbol "input-port"))))))
# == eliminate-cond  ==>
# (closure (f311027) (and and input-port) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? (port-kind f311027) (string->symbol "input-port"))))))
# == external-symbols  ==>
# (closure (f311027) (and and input-port) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))))))
# emit-expr (closure (f311027) (and and input-port) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311027) (and and input-port) (let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))))))
    movl $_L_1885084, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1885085            # jump around closure body
_L_1885084:
# check argument count
    cmp $4,%eax
    je _L_1885086
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885086:
# emit-tail-expr
# si=-12
# env=((f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(let ((f311027 f311027)) (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f311027 . -8) (input-port . 12) (and . 8) (and . 4))
#  bindings = ((f311027 f311027))
#  body = (and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))))
# emit-expr f311027
# emit-variable-ref
# env=((f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f311027
    movl -8(%esp), %eax  # stack load f311027
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f311027) (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f311027) (and (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port")))) #f)
# emit-expr (vector? f311027)
# emit-expr f311027
# emit-variable-ref
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f311027
    movl -12(%esp), %eax  # stack load f311027
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885087
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f311027) 8) (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f311027) 8) (and (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))) #f)
# emit-expr (fx= (vector-length f311027) 8)
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885091"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885091:
    movl %eax, -16(%esp)
# emit-expr (vector-length f311027)
# emit-expr f311027
# emit-variable-ref
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f311027
    movl -12(%esp), %eax  # stack load f311027
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885092
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885092:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885093"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885093:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885089
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) "input-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f311027) arg2=((primitive-ref string->symbol) "input-port")
# emit-expr ((primitive-ref port-kind) f311027)
# funcall
#    si   =-16
#    env  = ((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f311027)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885094"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885094":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311027
# emit-variable-ref
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f311027
    movl -12(%esp), %eax  # stack load f311027
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311027
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-20
#    env  = ((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885095"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885095":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_1885097
    .align 8,0x90
_L_1885096 :
    .int 40
    .ascii "input-port"
_L_1885097:
    movl $_L_1885096, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg input-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f311027) ((primitive-ref string->symbol) input-port))
    ret
    jmp _L_1885090
_L_1885089:
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1885090:
    jmp _L_1885088
_L_1885087:
# emit-tail-expr
# si=-16
# env=((f311027 . -12) (f311027 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1885088:
    .align 4,0x90
_L_1885085:
     movl %eax, mrc_input$mport$q
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == uniquify-variables  ==>
# (lambda (f311028) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? (port-kind f311028) (quote output-port)))))
# == vectorize-letrec  ==>
# (lambda (f311028) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? (port-kind f311028) (quote output-port)))))
# == eliminate-set!  ==>
# (lambda (f311028) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? (port-kind f311028) (quote output-port))))))
# == close-free-variables  ==>
# (closure (f311028) (and and output-port) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? (port-kind f311028) (quote output-port))))))
# == eliminate-quote  ==>
# (closure (f311028) (and and output-port) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? (port-kind f311028) (string->symbol "output-port"))))))
# == eliminate-when/unless  ==>
# (closure (f311028) (and and output-port) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? (port-kind f311028) (string->symbol "output-port"))))))
# == eliminate-cond  ==>
# (closure (f311028) (and and output-port) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? (port-kind f311028) (string->symbol "output-port"))))))
# == external-symbols  ==>
# (closure (f311028) (and and output-port) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))))))
# emit-expr (closure (f311028) (and and output-port) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311028) (and and output-port) (let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))))))
    movl $_L_1885098, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1885099            # jump around closure body
_L_1885098:
# check argument count
    cmp $4,%eax
    je _L_1885100
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885100:
# emit-tail-expr
# si=-12
# env=((f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(let ((f311028 f311028)) (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f311028 . -8) (output-port . 12) (and . 8) (and . 4))
#  bindings = ((f311028 f311028))
#  body = (and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))))
# emit-expr f311028
# emit-variable-ref
# env=((f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f311028
    movl -8(%esp), %eax  # stack load f311028
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f311028) (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f311028) (and (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port")))) #f)
# emit-expr (vector? f311028)
# emit-expr f311028
# emit-variable-ref
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f311028
    movl -12(%esp), %eax  # stack load f311028
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885101
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f311028) 6) (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f311028) 6) (and (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))) #f)
# emit-expr (fx= (vector-length f311028) 6)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885105"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885105:
    movl %eax, -16(%esp)
# emit-expr (vector-length f311028)
# emit-expr f311028
# emit-variable-ref
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f311028
    movl -12(%esp), %eax  # stack load f311028
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885106
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885106:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885107"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885107:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885103
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) "output-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f311028) arg2=((primitive-ref string->symbol) "output-port")
# emit-expr ((primitive-ref port-kind) f311028)
# funcall
#    si   =-16
#    env  = ((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f311028)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885108"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885108":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311028
# emit-variable-ref
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f311028
    movl -12(%esp), %eax  # stack load f311028
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311028
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-20
#    env  = ((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885109"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885109":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1885111
    .align 8,0x90
_L_1885110 :
    .int 44
    .ascii "output-port"
_L_1885111:
    movl $_L_1885110, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg output-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f311028) ((primitive-ref string->symbol) output-port))
    ret
    jmp _L_1885104
_L_1885103:
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1885104:
    jmp _L_1885102
_L_1885101:
# emit-tail-expr
# si=-16
# env=((f311028 . -12) (f311028 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1885102:
    .align 4,0x90
_L_1885099:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_read" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_read" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == uniquify-variables  ==>
# (lambda (f311029) (begin (unless (string? f311029) (error (quote open-input-file) "filename must be a string")) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (when (negative? f311035) (error (quote open-input-file) "open failed")) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 (quote input-port)) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039))))))
# == vectorize-letrec  ==>
# (lambda (f311029) (begin (unless (string? f311029) (error (quote open-input-file) "filename must be a string")) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (when (negative? f311035) (error (quote open-input-file) "open failed")) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 (quote input-port)) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039))))))
# == eliminate-set!  ==>
# (lambda (f311029) (let ((f311029 f311029)) (begin (unless (string? f311029) (error (quote open-input-file) "filename must be a string")) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (when (negative? f311035) (error (quote open-input-file) "open failed")) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 (quote input-port)) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
# == close-free-variables  ==>
# (closure (f311029) (input-port) (let ((f311029 f311029)) (begin (unless (string? f311029) (error (quote open-input-file) "filename must be a string")) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (when (negative? f311035) (error (quote open-input-file) "open failed")) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 (quote input-port)) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
# == eliminate-quote  ==>
# (closure (f311029) (input-port) (let ((f311029 f311029)) (begin (unless (string? f311029) (error (string->symbol "open-input-file") "filename must be a string")) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (when (negative? f311035) (error (string->symbol "open-input-file") "open failed")) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 (string->symbol "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
# == eliminate-when/unless  ==>
# (closure (f311029) (input-port) (let ((f311029 f311029)) (begin (if (not (string? f311029)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if (negative? f311035) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 (string->symbol "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
# == eliminate-cond  ==>
# (closure (f311029) (input-port) (let ((f311029 f311029)) (begin (if (not (string? f311029)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if (negative? f311035) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 (string->symbol "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
# == external-symbols  ==>
# (closure (f311029) (input-port) (let ((f311029 f311029)) (begin (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
# emit-expr (closure (f311029) (input-port) (let ((f311029 f311029)) (begin (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311029) (input-port) (let ((f311029 f311029)) (begin (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))))
    movl $_L_1885112, 0(%ebp)  # closure label
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885113            # jump around closure body
_L_1885112:
# check argument count
    cmp $4,%eax
    je _L_1885114
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885114:
# emit-tail-expr
# si=-12
# env=((f311029 . -8) (input-port . 4))
# expr=(let ((f311029 f311029)) (begin (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039))))))
# emit-tail-let
#  si   = -12
#  env  = ((f311029 . -8) (input-port . 4))
#  bindings = ((f311029 f311029))
#  body = (begin (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))
# emit-expr f311029
# emit-variable-ref
# env=((f311029 . -8) (input-port . 4))
# var=f311029
    movl -8(%esp), %eax  # stack load f311029
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))
# tail-begin (begin (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))
#   env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (if (not (string? f311029)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f)
# emit-expr (not (string? f311029))
# emit-expr (string? f311029)
# emit-expr f311029
# emit-variable-ref
# env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311029
    movl -12(%esp), %eax  # stack load f311029
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885115
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
#   env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f311029 . -12) (f311029 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885117"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885117":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-28
#    env  = ((f311029 . -12) (f311029 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885118"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885118":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_1885120
    .align 8,0x90
_L_1885119 :
    .int 60
    .ascii "open-input-file"
_L_1885120:
    movl $_L_1885119, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-input-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_1885122
    .align 8,0x90
_L_1885121 :
    .int 100
    .ascii "filename must be a string"
_L_1885122:
    movl $_L_1885121, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f311029 . -12) (f311029 . -8) (input-port . 4))
    jmp _L_1885116
_L_1885115:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1885116:
# emit-tail-expr
# si=-16
# env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))
# tail-begin (begin (let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))))
#   env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-tail-expr
# si=-16
# env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(let ((f311035 (foreign-call "s_open_for_read" f311029))) (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039))))
# emit-tail-let
#  si   = -16
#  env  = ((f311029 . -12) (f311029 . -8) (input-port . 4))
#  bindings = ((f311035 (foreign-call "s_open_for_read" f311029)))
#  body = (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))
# emit-expr (foreign-call "s_open_for_read" f311029)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f311029
# emit-variable-ref
# env=((f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311029
    movl -12(%esp), %eax  # stack load f311029
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open_for_read
    call _s_open_for_read
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))
# tail-begin (begin (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))
#   env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (if ((primitive-ref negative?) f311035) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f311035)
# funcall
#    si   =-20
#    env  = ((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref negative?) f311035)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885125"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885125":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f311035
# emit-variable-ref
# env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311035
    movl -16(%esp), %eax  # stack load f311035
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f311035
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1885123
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
#   env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885126"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885126":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-32
#    env  = ((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885127"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885127":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_1885129
    .align 8,0x90
_L_1885128 :
    .int 60
    .ascii "open-input-file"
_L_1885129:
    movl $_L_1885128, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-input-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "open failed"
# string literal
    jmp _L_1885131
    .align 8,0x90
_L_1885130 :
    .int 44
    .ascii "open failed"
_L_1885131:
    movl $_L_1885130, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
    jmp _L_1885124
_L_1885123:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1885124:
# emit-tail-expr
# si=-20
# env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))
# tail-begin (begin (let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)))
#   env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-tail-expr
# si=-20
# env=((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(let ((f311039 (make-vector 8)) (f311038 1024)) (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039))
# emit-tail-let
#  si   = -20
#  env  = ((f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
#  bindings = ((f311039 (make-vector 8)) (f311038 1024))
#  body = (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885132"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885132:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1885133
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885133:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885134
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885134:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885135"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885135:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885137
    cmp  $0,%eax
    jge _L_1885136
_L_1885137:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885136:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-36
#    env  = ((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885138"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885138":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_1885140
    .align 8,0x90
_L_1885139 :
    .int 40
    .ascii "input-port"
_L_1885140:
    movl $_L_1885139, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg input-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 1 f311029) (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 1 f311029)
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885141
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885141:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885142"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885142:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885144
    cmp  $0,%eax
    jge _L_1885143
_L_1885144:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885143:
    movl %eax, -32(%esp)
# emit-expr f311029
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311029
    movl -12(%esp), %eax  # stack load f311029
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 2 f311035) (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 2 f311035)
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885145
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885145:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885146"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885146:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885148
    cmp  $0,%eax
    jge _L_1885147
_L_1885148:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885147:
    movl %eax, -32(%esp)
# emit-expr f311035
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311035
    movl -16(%esp), %eax  # stack load f311035
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 3 (make-string f311038)) (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 3 (make-string f311038))
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885149
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885149:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885150"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885150:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885152
    cmp  $0,%eax
    jge _L_1885151
_L_1885152:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885151:
    movl %eax, -32(%esp)
# emit-expr (make-string f311038)
# make-string len=f311038
# emit-expr f311038
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311038
    movl -24(%esp), %eax  # stack load f311038
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885153"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885153:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1885154
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885154:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 4 0) (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 4 0)
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885155
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885155:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885156"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885156:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885158
    cmp  $0,%eax
    jge _L_1885157
_L_1885158:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885157:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 5 f311038) (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 5 f311038)
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885159
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885159:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885160"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885160:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885162
    cmp  $0,%eax
    jge _L_1885161
_L_1885162:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885161:
    movl %eax, -32(%esp)
# emit-expr f311038
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311038
    movl -24(%esp), %eax  # stack load f311038
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 6 #f) (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 6 #f)
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885163
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885163:
    movl %eax, -28(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885164"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885164:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885166
    cmp  $0,%eax
    jge _L_1885165
_L_1885166:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885165:
    movl %eax, -32(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin (vector-set! f311039 7 0) f311039)
# tail-begin (begin (vector-set! f311039 7 0) f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-expr (vector-set! f311039 7 0)
# emit-expr f311039
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1885167
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885167:
    movl %eax, -28(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885168"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885168:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1885170
    cmp  $0,%eax
    jge _L_1885169
_L_1885170:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885169:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=(begin f311039)
# tail-begin (begin f311039)
#   env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# emit-tail-expr
# si=-28
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# expr=f311039
# emit-tail-variable-ref
# emit-variable-ref
# env=((f311038 . -24) (f311039 . -20) (f311035 . -16) (f311029 . -12) (f311029 . -8) (input-port . 4))
# var=f311039
    movl -20(%esp), %eax  # stack load f311039
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_1885113:
     movl %eax, mrc_open$minput$mfile
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == uniquify-variables  ==>
# (lambda f311040 (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049))))))))
# == vectorize-letrec  ==>
# (lambda f311040 (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049))))))))
# == eliminate-set!  ==>
# (lambda f311040 (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == close-free-variables  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == eliminate-quote  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == eliminate-when/unless  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (if (not (eof-object? (port-unread f311046))) (begin (port-unread-clear f311046)) #f) f311050))) (else (begin (if (fx= (port-last f311046) (port-ndx f311046)) (begin (fill-input-buffer f311046)) #f) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == eliminate-cond  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (if (port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (if (not (eof-object? (port-unread f311046))) (begin (port-unread-clear f311046)) #f) f311050)) (begin (if (fx= (port-last f311046) (port-ndx f311046)) (begin (fill-input-buffer f311046)) #f) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049))))))))
# == external-symbols  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))))
# emit-expr (closure f311040 () (let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f311040 () (let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))))
    movl $_L_1885171, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885172            # jump around closure body
_L_1885171:
# check argument count
    cmp $0,%eax
    jge _L_1885173
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885173:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1885175:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1885174
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1885175
_L_1885174:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f311040 . -8))
# expr=(let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))))))
# emit-tail-let
#  si   = -12
#  env  = ((f311040 . -8))
#  bindings = ()
#  body = (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))
# emit-tail-expr
# si=-12
# env=((f311040 . -8))
# expr=(let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))
# emit-tail-let
#  si   = -12
#  env  = ((f311040 . -8))
#  bindings = ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040))))
#  body = (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))))
# emit-expr (if (null? f311040) ((primitive-ref current-input-port)) (car f311040))
# emit-expr (null? f311040)
# emit-expr f311040
# emit-variable-ref
# env=((f311040 . -8))
# var=f311040
    movl -8(%esp), %eax  # stack load f311040
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885176
# emit-expr ((primitive-ref current-input-port))
# funcall
#    si   =-12
#    env  = ((f311040 . -8))
#    expr = (funcall (primitive-ref current-input-port))
# emit-expr (primitive-ref current-input-port)
    .extern mrc_current$minput$mport
    movl mrc_current$minput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885178"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885178":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1885177
_L_1885176:
# emit-expr (car f311040)
# emit-expr f311040
# emit-variable-ref
# env=((f311040 . -8))
# var=f311040
    movl -8(%esp), %eax  # stack load f311040
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1885179
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885179:
    movl -1(%eax), %eax
_L_1885177:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=(if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))))
# emit-expr ((primitive-ref port-unread) f311046)
# funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread) f311046)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885182"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885182":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311046
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1885180
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=(let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050))
# emit-tail-let
#  si   = -16
#  env  = ((f311046 . -12) (f311040 . -8))
#  bindings = ((f311050 ((primitive-ref port-unread) f311046)))
#  body = (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)
# emit-expr ((primitive-ref port-unread) f311046)
# funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread) f311046)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885183"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885183":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311046
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)
# tail-begin (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# emit-expr (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f)
# emit-expr (not (eof-object? ((primitive-ref port-unread) f311046)))
# emit-expr (eof-object? ((primitive-ref port-unread) f311046))
# emit-expr ((primitive-ref port-unread) f311046)
# funcall
#    si   =-20
#    env  = ((f311050 . -16) (f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread) f311046)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885186"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885186":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f311046
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $95, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885184
# emit-expr (begin ((primitive-ref port-unread-clear) f311046))
# emit-begin
#   expr=(begin ((primitive-ref port-unread-clear) f311046))
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# emit-expr ((primitive-ref port-unread-clear) f311046)
# funcall
#    si   =-20
#    env  = ((f311050 . -16) (f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread-clear) f311046)
# emit-expr (primitive-ref port-unread-clear)
    .extern mrc_port$munread$mclear
    movl mrc_port$munread$mclear,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885187"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885187":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f311046
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
    jmp _L_1885185
_L_1885184:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1885185:
# emit-tail-expr
# si=-20
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin f311050)
# tail-begin (begin f311050)
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# emit-tail-expr
# si=-20
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# expr=f311050
# emit-tail-variable-ref
# emit-variable-ref
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# var=f311050
    movl -16(%esp), %eax  # stack load f311050
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_1885181
_L_1885180:
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=(begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
# tail-begin (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
#   env=((f311046 . -12) (f311040 . -8))
# emit-expr (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f)
# emit-expr (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046))
# emit-expr ((primitive-ref port-ndx) f311046)
# funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-ndx) f311046)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885190"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885190":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311046
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885191"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885191:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-last) f311046)
# funcall
#    si   =-20
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-last) f311046)
# emit-expr (primitive-ref port-last)
    .extern mrc_port$mlast
    movl mrc_port$mlast,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885192"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885192":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f311046
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885193"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885193:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885188
# emit-expr (begin ((primitive-ref fill-input-buffer) f311046))
# emit-begin
#   expr=(begin ((primitive-ref fill-input-buffer) f311046))
#   env=((f311046 . -12) (f311040 . -8))
# emit-expr ((primitive-ref fill-input-buffer) f311046)
# funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref fill-input-buffer) f311046)
# emit-expr (primitive-ref fill-input-buffer)
    .extern mrc_fill$minput$mbuffer
    movl mrc_fill$minput$mbuffer,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885194"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885194":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311046
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f311046 . -12) (f311040 . -8))
    jmp _L_1885189
_L_1885188:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1885189:
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=(begin (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
# tail-begin (begin (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
#   env=((f311046 . -12) (f311040 . -8))
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=(if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))
# emit-expr ((primitive-ref port-unread) f311046)
# funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread) f311046)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885197"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885197":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311046
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1885195
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=((primitive-ref port-unread) f311046)
# emit-tail-funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread) f311046)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f311046
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1885196
_L_1885195:
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=(let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))
# emit-tail-let
#  si   = -16
#  env  = ((f311046 . -12) (f311040 . -8))
#  bindings = ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046))))
#  body = (begin ((primitive-ref port-ndx-add1) f311046) f311049)
# emit-expr (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046))
# emit-expr ((primitive-ref port-buf) f311046)
# funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-buf) f311046)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885198"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885198":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311046
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1885199
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885199:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-ndx) f311046)
# funcall
#    si   =-16
#    env  = ((f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-ndx) f311046)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885200"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885200":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f311046
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885201"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885201:
# check bounds on string index
    movl -16(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1885203
    cmp  $0,%eax
    jge _L_1885202
_L_1885203:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1885202:
    sar $2, %eax
    movl -16(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f311046) f311049)
# tail-begin (begin ((primitive-ref port-ndx-add1) f311046) f311049)
#   env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# emit-expr ((primitive-ref port-ndx-add1) f311046)
# funcall
#    si   =-20
#    env  = ((f311049 . -16) (f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f311046)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885204"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885204":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f311046
# emit-variable-ref
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f311046
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin f311049)
# tail-begin (begin f311049)
#   env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# emit-tail-expr
# si=-20
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# expr=f311049
# emit-tail-variable-ref
# emit-variable-ref
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# var=f311049
    movl -16(%esp), %eax  # stack load f311049
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
_L_1885196:
     ret   # return thru stack
_L_1885181:
    .align 4,0x90
_L_1885172:
     movl %eax, mrc_read$mchar
# == explicit-begins  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == eliminate-let*  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == uniquify-variables  ==>
# (lambda (f311051) (let ((f311053 (foreign-call "s_read" (port-fd f311051) (port-buf f311051) (port-size f311051)))) (begin (port-ndx-reset f311051) (port-last-set! f311051 f311053) (when (fxzero? f311053) (port-unread-set! f311051 (eof-object))))))
# == vectorize-letrec  ==>
# (lambda (f311051) (let ((f311053 (foreign-call "s_read" (port-fd f311051) (port-buf f311051) (port-size f311051)))) (begin (port-ndx-reset f311051) (port-last-set! f311051 f311053) (when (fxzero? f311053) (port-unread-set! f311051 (eof-object))))))
# == eliminate-set!  ==>
# (lambda (f311051) (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" (port-fd f311051) (port-buf f311051) (port-size f311051)))) (begin (port-ndx-reset f311051) (port-last-set! f311051 f311053) (when (fxzero? f311053) (port-unread-set! f311051 (eof-object)))))))
# == close-free-variables  ==>
# (closure (f311051) () (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" (port-fd f311051) (port-buf f311051) (port-size f311051)))) (begin (port-ndx-reset f311051) (port-last-set! f311051 f311053) (when (fxzero? f311053) (port-unread-set! f311051 (eof-object)))))))
# == eliminate-quote  ==>
# (closure (f311051) () (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" (port-fd f311051) (port-buf f311051) (port-size f311051)))) (begin (port-ndx-reset f311051) (port-last-set! f311051 f311053) (when (fxzero? f311053) (port-unread-set! f311051 (eof-object)))))))
# == eliminate-when/unless  ==>
# (closure (f311051) () (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" (port-fd f311051) (port-buf f311051) (port-size f311051)))) (begin (port-ndx-reset f311051) (port-last-set! f311051 f311053) (if (fxzero? f311053) (begin (port-unread-set! f311051 (eof-object))) #f)))))
# == eliminate-cond  ==>
# (closure (f311051) () (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" (port-fd f311051) (port-buf f311051) (port-size f311051)))) (begin (port-ndx-reset f311051) (port-last-set! f311051 f311053) (if (fxzero? f311053) (begin (port-unread-set! f311051 (eof-object))) #f)))))
# == external-symbols  ==>
# (closure (f311051) () (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051)))) (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f)))))
# emit-expr (closure (f311051) () (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051)))) (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311051) () (let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051)))) (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f)))))
    movl $_L_1885205, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1885206            # jump around closure body
_L_1885205:
# check argument count
    cmp $4,%eax
    je _L_1885207
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1885207:
# emit-tail-expr
# si=-12
# env=((f311051 . -8))
# expr=(let ((f311051 f311051)) (let ((f311053 (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051)))) (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))))
# emit-tail-let
#  si   = -12
#  env  = ((f311051 . -8))
#  bindings = ((f311051 f311051))
#  body = (let ((f311053 (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051)))) (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f)))
# emit-expr f311051
# emit-variable-ref
# env=((f311051 . -8))
# var=f311051
    movl -8(%esp), %eax  # stack load f311051
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f311051 . -12) (f311051 . -8))
# expr=(let ((f311053 (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051)))) (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f311051 . -12) (f311051 . -8))
#  bindings = ((f311053 (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051))))
#  body = (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))
# emit-expr (foreign-call "s_read" ((primitive-ref port-fd) f311051) ((primitive-ref port-buf) f311051) ((primitive-ref port-size) f311051))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-size) f311051)
# funcall
#    si   =-24
#    env  = ((f311051 . -12) (f311051 . -8))
#    expr = (funcall (primitive-ref port-size) f311051)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885208"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885208":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f311051
# emit-variable-ref
# env=((f311051 . -12) (f311051 . -8))
# var=f311051
    movl -12(%esp), %eax  # stack load f311051
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f311051
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f311051)
# funcall
#    si   =-28
#    env  = ((f311051 . -12) (f311051 . -8))
#    expr = (funcall (primitive-ref port-buf) f311051)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885209"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885209":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f311051
# emit-variable-ref
# env=((f311051 . -12) (f311051 . -8))
# var=f311051
    movl -12(%esp), %eax  # stack load f311051
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f311051
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f311051)
# funcall
#    si   =-32
#    env  = ((f311051 . -12) (f311051 . -8))
#    expr = (funcall (primitive-ref port-fd) f311051)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885210"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885210":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f311051
# emit-variable-ref
# env=((f311051 . -12) (f311051 . -8))
# var=f311051
    movl -12(%esp), %eax  # stack load f311051
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f311051
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_read
    call _s_read
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-ndx-reset) f311051) ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))
#   env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# emit-expr ((primitive-ref port-ndx-reset) f311051)
# funcall
#    si   =-20
#    env  = ((f311053 . -16) (f311051 . -12) (f311051 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f311051)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885211"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885211":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f311051
# emit-variable-ref
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# var=f311051
    movl -12(%esp), %eax  # stack load f311051
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f311051
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# expr=(begin ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-last-set!) f311051 f311053) (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))
#   env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# emit-expr ((primitive-ref port-last-set!) f311051 f311053)
# funcall
#    si   =-20
#    env  = ((f311053 . -16) (f311051 . -12) (f311051 . -8))
#    expr = (funcall (primitive-ref port-last-set!) f311051 f311053)
# emit-expr (primitive-ref port-last-set!)
    .extern mrc_port$mlast$mset$b
    movl mrc_port$mlast$mset$b,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885212"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885212":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f311051
# emit-variable-ref
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# var=f311051
    movl -12(%esp), %eax  # stack load f311051
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f311051
# emit-expr f311053
# emit-variable-ref
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# var=f311053
    movl -16(%esp), %eax  # stack load f311053
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f311053
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# expr=(begin (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))
# tail-begin (begin (if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f))
#   env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# emit-tail-expr
# si=-20
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# expr=(if (fxzero? f311053) (begin ((primitive-ref port-unread-set!) f311051 (eof-object))) #f)
# emit-expr (fxzero? f311053)
# emit-expr f311053
# emit-variable-ref
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# var=f311053
    movl -16(%esp), %eax  # stack load f311053
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1885215"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1885215:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1885213
# emit-tail-expr
# si=-20
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# expr=(begin ((primitive-ref port-unread-set!) f311051 (eof-object)))
# tail-begin (begin ((primitive-ref port-unread-set!) f311051 (eof-object)))
#   env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# emit-tail-expr
# si=-20
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# expr=((primitive-ref port-unread-set!) f311051 (eof-object))
# emit-tail-funcall
#    si   =-20
#    env  = ((f311053 . -16) (f311051 . -12) (f311051 . -8))
#    expr = (funcall (primitive-ref port-unread-set!) f311051 (eof-object))
# emit-expr (primitive-ref port-unread-set!)
    .extern mrc_port$munread$mset$b
    movl mrc_port$munread$mset$b,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f311051
# emit-variable-ref
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# var=f311051
    movl -12(%esp), %eax  # stack load f311051
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f311051
# emit-expr (eof-object)
    movl $95,%eax
    mov %eax, -28(%esp)    # arg (eof-object)
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=16
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=16
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1885214
_L_1885213:
# emit-tail-expr
# si=-20
# env=((f311053 . -16) (f311051 . -12) (f311051 . -8))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1885214:
     ret   # return thru stack
    .align 4,0x90
_L_1885206:
     movl %eax, mrc_fill$minput$mbuffer
# == explicit-begins  ==>
# (quote TBD)
# == eliminate-let*  ==>
# (quote TBD)
# == uniquify-variables  ==>
# (quote TBD)
# == vectorize-letrec  ==>
# (quote TBD)
# == eliminate-set!  ==>
# (quote TBD)
# == close-free-variables  ==>
# (quote TBD)
# == eliminate-quote  ==>
# (string->symbol "TBD")
# == eliminate-when/unless  ==>
# (string->symbol "TBD")
# == eliminate-cond  ==>
# (string->symbol "TBD")
# == external-symbols  ==>
# ((primitive-ref string->symbol) "TBD")
# emit-expr ((primitive-ref string->symbol) "TBD")
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref string->symbol) "TBD")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1885216"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1885216":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr "TBD"
# string literal
    jmp _L_1885218
    .align 8,0x90
_L_1885217 :
    .int 12
    .ascii "TBD"
_L_1885218:
    movl $_L_1885217, %eax
    orl $6, %eax
    mov %eax, -12(%esp)  # arg TBD
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
     movl %eax, mrc_unread$mchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
