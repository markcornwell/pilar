Petite Chez Scheme Version 8.4
Copyright (c) 1985-2011 Cadence Research Systems

> Performing exit tests ...
test 0:(foreign-call "s_foo") ... ok
test 1:(foreign-call "exit" 0) ... ok
Performing write tests ...
test 2:(foreign-call "s_42") ... ok
test 3:(foreign-call "s_true") ... ok
test 4:(foreign-call "s_false") ... ok
test 5:(foreign-call "s_once" 0) ... ok
test 6:((lambda () (foreign-call "s_twice" 2))) ... ok
test 7:(foreign-call "s_once" 1) ... ok
test 8:(foreign-call "s_once" 2) ... ok
test 9:(foreign-call "s_twice" 2) ... ok
test 10:(foreign-call "s_twice" 250) ... ok
test 11:(foreign-call "s_foo") ... ok
test 12:(foreign-call "s_write_foo") ... ok
test 13:(foreign-call "s_write_hello") ... ok
test 14:(foreign-call "s_exit") ... ok
test 15:(foreign-call "s_write" 1 "hello world" 11) ... ok
test 16:(foreign-call "s_write" 1 "hello world" (string-length "hello world")) ... ok
Performing error tests ...
test 17:(let* ((write-stderr (lambda (s) (foreign-call "s_write" 1 s (string-length s)))) (write-emsg (lambda (sym emsg) (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n")))) (write-emsg (quote car) "argument not a pair") #f) ... ok
test 18:(let* ((write-stderr (lambda (s) (foreign-call "s_write" 1 s (string-length s)))) (write-emsg (lambda (sym emsg) (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n")))) (write-emsg (quote car) "argument not a pair") (foreign-call "s_exit" 1) #f) ... ok
test 19:(error (quote car) "argument must be a pair") ... ok
test 20:(error (quote cdr) "argument must be a pair") ... ok
test 21:(error (quote funcall) "first arg must be a procedure") ... ok
Performing primitives list tests ...
test 22:(primitives) ... ok
test 23:(list-ref (primitives) 0) ... ok
test 24:(list-ref (primitives) 1) ... ok
test 25:(list-ref (primitives) 2) ... ok
test 26:(list-ref (primitives) 3) ... ok
Performing error handlers tests ...
test 27:(funcall #t) ... ok
test 28:(funcall 14) ... ok
test 29:(funcall #\A) ... ok
test 30:(funcall "foo") ... ok
test 31:(funcall (quote a)) ... ok
test 32:(funcall (quote fx+) 13 14) ... ok
test 33:(funcall (quote car)) ... ok
test 34:(funcall (quote funcall)) ... ok
test 35:(funcall (let ((x 2)) (fx+ x x))) ... ok
test 36:(funcall (quote (a b))) ... ok
test 37:(fixnum->char #t) ... ok
test 38:(char->fixnum 42) ... ok
test 39:(char=? #\A #t) ... ok
test 40:(char=? #f #\B) ... ok
test 41:(char=? #t 14) ... ok
test 42:(fxlognot #t) ... ok
test 43:(fxlogand #t #f) ... ok
test 44:(fxlogor #t 12) ... ok
test 45:(fxadd1 #f) ... ok
test 46:(fxsub1 #\M) ... ok
test 47:(fxzero? #f) ... ok
test 48:(fx= #f 4) ... ok
test 49:(fx= 4 #t) ... ok
test 50:(fx<= #f 3) ... ok
test 51:(fx<= 3 #t) ... ok
test 52:(fx< #f 3) ... ok
test 53:(fx< 3 #t) ... ok
test 54:(fx>= #f 3) ... ok
test 55:(fx>= 3 #t) ... ok
test 56:(fx> #f 3) ... ok
test 57:(fx> 3 #t) ... ok
test 58:(fx+ #f 3) ... ok
test 59:(fx+ 3 #t) ... ok
test 60:(fx- #f 3) ... ok
test 61:(fx- 3 #t) ... ok
test 62:(fx* #f 3) ... ok
test 63:(fx* 3 #t) ... ok
test 64:((lambda (x y) (cons x y)) 1 2 3) ... ok
test 65:((lambda (x y) (cons x y)) 1) ... ok
test 66:(cons 1 1) ... ok
test 67:(car #f) ... ok
test 68:(cdr 43) ... ok
test 69:(set-car! "foo" 42) ... ok
test 70:(set-cdr! #\A #f) ... ok
test 71:(make-vector #t) ...> 
